import { GraphQLClient, RequestOptions } from 'graphql-request';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
type GraphQLClientRequestHeaders = RequestOptions['requestHeaders'];
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigInt: { input: any; output: any; }
  Blob: { input: any; output: any; }
  DateTime: { input: any; output: any; }
};

/** Personal access tokens */
export type AccessToken = Node & {
  __typename?: 'AccessToken';
  createdAt: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  descriptionHtml: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** It returns true if (1) the access token is not revoked, and (2) the author of the access token is alive. */
  isActive: Scalars['Boolean']['output'];
  isRevoked: Scalars['Boolean']['output'];
  lastUsedAt?: Maybe<Scalars['DateTime']['output']>;
  logs: AccessTokenLogConnection;
  path: Scalars['String']['output'];
  scopes: Array<AccessTokenScope>;
  title: Scalars['String']['output'];
  /** The secret token value, which is only available via `createAccessToken` mutation. */
  token?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  /** The author of the access token */
  user: User;
};


/** Personal access tokens */
export type AccessTokenLogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for AccessToken. */
export type AccessTokenConnection = {
  __typename?: 'AccessTokenConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessTokenEdge>>>;
  /** A list of nodes. */
  nodes: Array<AccessToken>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AccessTokenEdge = {
  __typename?: 'AccessTokenEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AccessToken>;
};

/** Usage logs for personal access tokens */
export type AccessTokenLog = Node & {
  __typename?: 'AccessTokenLog';
  accessToken: AccessToken;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  ipAddress: Scalars['String']['output'];
  operationType: Scalars['String']['output'];
  query: Scalars['String']['output'];
  user: User;
  userAgent: Scalars['String']['output'];
};

/** The connection type for AccessTokenLog. */
export type AccessTokenLogConnection = {
  __typename?: 'AccessTokenLogConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessTokenLogEdge>>>;
  /** A list of nodes. */
  nodes: Array<AccessTokenLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AccessTokenLogEdge = {
  __typename?: 'AccessTokenLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AccessTokenLog>;
};

export enum AccessTokenScope {
  /** @deprecated Not yet implemented */
  Administer = 'ADMINISTER',
  Read = 'READ',
  Write = 'WRITE'
}

/** Autogenerated input type of AddUsersToUserList */
export type AddUsersToUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  userIds: Array<Scalars['ID']['input']>;
  userListId: Scalars['ID']['input'];
};

/** Autogenerated return type of AddUsersToUserList. */
export type AddUsersToUserListPayload = {
  __typename?: 'AddUsersToUserListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  userList: UserList;
};

export type AiReview = {
  __typename?: 'AiReview';
  comment?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  newContent?: Maybe<Scalars['String']['output']>;
  newTitle?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated return type of AiReviewUpdated. */
export type AiReviewUpdatedPayload = {
  __typename?: 'AiReviewUpdatedPayload';
  aiReview: AiReview;
};

/** Autogenerated input type of ArchiveFolder */
export type ArchiveFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ArchiveFolder. */
export type ArchiveFolderPayload = {
  __typename?: 'ArchiveFolderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String']['output'];
};

/** Autogenerated input type of ArchiveFolders */
export type ArchiveFoldersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ArchiveFolders. */
export type ArchiveFoldersPayload = {
  __typename?: 'ArchiveFoldersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  folders: Array<Folder>;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String']['output'];
};

/** Autogenerated input type of ArchiveGroup */
export type ArchiveGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
};

/** Autogenerated return type of ArchiveGroup. */
export type ArchiveGroupPayload = {
  __typename?: 'ArchiveGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

/** Autogenerated input type of ArchiveNote */
export type ArchiveNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ArchiveNote. */
export type ArchiveNotePayload = {
  __typename?: 'ArchiveNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** Autogenerated input type of ArchiveNotes */
export type ArchiveNotesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of ArchiveNotes. */
export type ArchiveNotesPayload = {
  __typename?: 'ArchiveNotesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  notes: Array<Note>;
};

/** Autogenerated input type of AttachNoteToFolder */
export type AttachNoteToFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  folder: FolderInput;
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of AttachNoteToFolder. */
export type AttachNoteToFolderPayload = {
  __typename?: 'AttachNoteToFolderPayload';
  attachedFolder: Folder;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String']['output'];
  note: Note;
};

export type Attachment = Node & {
  __typename?: 'Attachment';
  author: User;
  createdAt: Scalars['DateTime']['output'];
  /** The data of the attachment in binary. Prefer `data_url` if you use JSON for serializers */
  data: Scalars['Blob']['output'];
  /** The same value as `data` but encoded in data URL schema */
  dataUrl: Scalars['String']['output'];
  filePreview?: Maybe<AttachmentFilePreview>;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  kind: AttachmentKind;
  /** @deprecated This feature is for internal use only. */
  metadata: Scalars['String']['output'];
  /** A MIME type detected from its data and name */
  mimeType: Scalars['String']['output'];
  name: Scalars['String']['output'];
  path: Scalars['String']['output'];
  /** The file size */
  size: Scalars['Int']['output'];
  url: Scalars['String']['output'];
};

/** The connection type for Attachment. */
export type AttachmentConnection = {
  __typename?: 'AttachmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AttachmentEdge>>>;
  /** A list of nodes. */
  nodes: Array<Attachment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AttachmentEdge = {
  __typename?: 'AttachmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Attachment>;
};

export type AttachmentFilePreview = Node & {
  __typename?: 'AttachmentFilePreview';
  asset?: Maybe<AttachmentFilePreviewAsset>;
  attemptsCount: Scalars['Int']['output'];
  conversionState: AttachmentFilePreviewConversionState;
  id: Scalars['ID']['output'];
  lastPreviewedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type AttachmentFilePreviewAsset = Node & {
  __typename?: 'AttachmentFilePreviewAsset';
  height: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  width: Scalars['Int']['output'];
};

export enum AttachmentFilePreviewConversionState {
  Failed = 'FAILED',
  LimitExceeded = 'LIMIT_EXCEEDED',
  None = 'NONE',
  Processing = 'PROCESSING',
  Success = 'SUCCESS'
}

/** How and where the attachment is used. */
export enum AttachmentKind {
  General = 'GENERAL',
  GroupCoverImage = 'GROUP_COVER_IMAGE',
  UserAvatarImage = 'USER_AVATAR_IMAGE',
  UserCoverImage = 'USER_COVER_IMAGE'
}

/** Kibela Web API budget like RateLimit of RESTful API */
export type Budget = {
  __typename?: 'Budget';
  consumed: Scalars['BigInt']['output'];
  /** The point cost for the current query counting against the budget. */
  cost: Scalars['BigInt']['output'];
  remaining: Scalars['BigInt']['output'];
};

/** Autogenerated input type of ChangeGroupPermissionOfUserList */
export type ChangeGroupPermissionOfUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  role: GroupMemberRole;
  userListId: Scalars['ID']['input'];
};

/** Autogenerated return type of ChangeGroupPermissionOfUserList. */
export type ChangeGroupPermissionOfUserListPayload = {
  __typename?: 'ChangeGroupPermissionOfUserListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CloseAnnouncement */
export type CloseAnnouncementInput = {
  announcementKey: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CloseAnnouncement. */
export type CloseAnnouncementPayload = {
  __typename?: 'CloseAnnouncementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** The Note coedit room type */
export type CoeditRoom = Node & {
  __typename?: 'CoeditRoom';
  activeUserAccounts: Array<Scalars['String']['output']>;
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** The contents of Note being edited in collab mode. */
export type CollabModeData = {
  __typename?: 'CollabModeData';
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  contentTocHtml: Scalars['String']['output'];
  folders?: Maybe<FolderConnection>;
  groups?: Maybe<Array<Group>>;
  memberCount: Scalars['Int']['output'];
  publishPlacesChanged: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
};


/** The contents of Note being edited in collab mode. */
export type CollabModeDataFoldersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A comment that belongs to a Note */
export type Comment = CommentInterface & Node & {
  __typename?: 'Comment';
  anchor: Scalars['String']['output'];
  author: User;
  canBeLiked: Scalars['Boolean']['output'];
  canBeResolved: Scalars['Boolean']['output'];
  canBeUpdated: Scalars['Boolean']['output'];
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  contentSummaryHtml: Scalars['String']['output'];
  contentUpdatedAt: Scalars['DateTime']['output'];
  contributors: UserConnection;
  createdAt: Scalars['DateTime']['output'];
  editedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  isEdited: Scalars['Boolean']['output'];
  isLikedByCurrentUser: Scalars['Boolean']['output'];
  likers: UserConnection;
  path: Scalars['String']['output'];
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  replies: CommentReplyConnection;
  updatedAt: Scalars['DateTime']['output'];
};


/** A comment that belongs to a Note */
export type CommentContributorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributorOrder>;
};


/** A comment that belongs to a Note */
export type CommentLikersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A comment that belongs to a Note */
export type CommentRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Comment. */
export type CommentConnection = {
  __typename?: 'CommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentEdge>>>;
  /** A list of nodes. */
  nodes: Array<Comment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename?: 'CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

export type CommentInterface = {
  anchor: Scalars['String']['output'];
  author: User;
  canBeLiked: Scalars['Boolean']['output'];
  canBeResolved: Scalars['Boolean']['output'];
  canBeUpdated: Scalars['Boolean']['output'];
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  contentSummaryHtml: Scalars['String']['output'];
  contentUpdatedAt: Scalars['DateTime']['output'];
  contributors: UserConnection;
  createdAt: Scalars['DateTime']['output'];
  editedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  isEdited: Scalars['Boolean']['output'];
  isLikedByCurrentUser: Scalars['Boolean']['output'];
  likers: UserConnection;
  path: Scalars['String']['output'];
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  replies: CommentReplyConnection;
  updatedAt: Scalars['DateTime']['output'];
};


export type CommentInterfaceContributorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributorOrder>;
};


export type CommentInterfaceLikersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type CommentInterfaceRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The Comment Reply type */
export type CommentReply = Node & {
  __typename?: 'CommentReply';
  anchor: Scalars['String']['output'];
  author: User;
  canBeLiked: Scalars['Boolean']['output'];
  canBeUpdated: Scalars['Boolean']['output'];
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  contentSummaryHtml: Scalars['String']['output'];
  contentUpdatedAt: Scalars['DateTime']['output'];
  contributors: UserConnection;
  createdAt: Scalars['DateTime']['output'];
  editedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  isEdited: Scalars['Boolean']['output'];
  isLikedByCurrentUser: Scalars['Boolean']['output'];
  likers: UserConnection;
  path: Scalars['String']['output'];
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};


/** The Comment Reply type */
export type CommentReplyContributorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributorOrder>;
};


/** The Comment Reply type */
export type CommentReplyLikersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for CommentReply. */
export type CommentReplyConnection = {
  __typename?: 'CommentReplyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentReplyEdge>>>;
  /** A list of nodes. */
  nodes: Array<CommentReply>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CommentReplyEdge = {
  __typename?: 'CommentReplyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CommentReply>;
};

/** A contributor in the coedit mode */
export type ContributorInput = {
  account: Scalars['String']['input'];
  joinOrder: Scalars['Int']['input'];
};

export type ContributorOrder = {
  direction?: InputMaybe<OrderDirection>;
  field?: InputMaybe<ContributorOrderField>;
};

/** Properties by which contributors can be ordered. */
export enum ContributorOrderField {
  ContributedAt = 'CONTRIBUTED_AT'
}

/** Autogenerated input type of CreateAccessToken */
export type CreateAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  scopes: Array<AccessTokenScope>;
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateAccessToken. */
export type CreateAccessTokenPayload = {
  __typename?: 'CreateAccessTokenPayload';
  /** It includes the secret `token`, which you never see again. */
  accessToken: AccessToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateAiReview */
export type CreateAiReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  content: Scalars['String']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateAiReview. */
export type CreateAiReviewPayload = {
  __typename?: 'CreateAiReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
};

/** Autogenerated input type of CreateComment */
export type CreateCommentInput = {
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   * Note that the contributors still include the user who executes this mutation in order to avoid spoofing.
   *
   */
  authorId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  commentableId: Scalars['ID']['input'];
  content: Scalars['String']['input'];
  /** The time when the comment is published. If not specified, `createdAt` is set to `publishedAt` */
  publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Autogenerated return type of CreateComment. */
export type CreateCommentPayload = {
  __typename?: 'CreateCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  comment: Comment;
};

/** Autogenerated input type of CreateCommentReply */
export type CreateCommentReplyInput = {
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   * Note that the contributors still include the user who executes this mutation in order to avoid spoofing.
   *
   */
  authorId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  commentId: Scalars['ID']['input'];
  content: Scalars['String']['input'];
  /** The time when the comment is published. If not specified, `createdAt` is set to `publishedAt` */
  publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Autogenerated return type of CreateCommentReply. */
export type CreateCommentReplyPayload = {
  __typename?: 'CreateCommentReplyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  reply: CommentReply;
};

/** Autogenerated input type of CreateCustomEmoji */
export type CreateCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Up to 50 alphanumeric characters and underscores(_) can be used. */
  emojiCode: Scalars['String']['input'];
  /** BASE64 encoded image data URL */
  imageDataUrl: Scalars['String']['input'];
};

/** Autogenerated return type of CreateCustomEmoji. */
export type CreateCustomEmojiPayload = {
  __typename?: 'CreateCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  customEmoji: CustomEmoji;
};

/** Autogenerated input type of CreateDisabledUser */
export type CreateDisabledUserInput = {
  /** `account` must be unique in the team */
  account: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** `email` must be unique in the team */
  email: Scalars['String']['input'];
  realName: Scalars['String']['input'];
  role?: InputMaybe<Role>;
};

/** Autogenerated return type of CreateDisabledUser. */
export type CreateDisabledUserPayload = {
  __typename?: 'CreateDisabledUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

/** Autogenerated input type of CreateFolder */
export type CreateFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  folder?: InputMaybe<FolderInput>;
};

/** Autogenerated return type of CreateFolder. */
export type CreateFolderPayload = {
  __typename?: 'CreateFolderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String']['output'];
};

/** Autogenerated input type of CreateFolderPin */
export type CreateFolderPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Target folder. It is required when the note has 2 or more associated folders. */
  folder?: InputMaybe<FolderInput>;
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateFolderPin. */
export type CreateFolderPinPayload = {
  __typename?: 'CreateFolderPinPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  folder: Folder;
};

/** Autogenerated input type of CreateGroupAnnouncement */
export type CreateGroupAnnouncementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  referentFolders: Array<GroupAnnouncementFolderInput>;
};

/** Autogenerated return type of CreateGroupAnnouncement. */
export type CreateGroupAnnouncementPayload = {
  __typename?: 'CreateGroupAnnouncementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  groupAnnouncement: GroupAnnouncement;
};

/** Autogenerated input type of CreateGroup */
export type CreateGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  coverImageKey?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  isPrivate: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  type?: InputMaybe<GroupType>;
};

/** Autogenerated return type of CreateGroup. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

/** Autogenerated input type of CreateGroupPin */
export type CreateGroupPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateGroupPin. */
export type CreateGroupPinPayload = {
  __typename?: 'CreateGroupPinPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

/** Autogenerated input type of CreateInlineComment */
export type CreateInlineCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  content: Scalars['String']['input'];
  endInText: Scalars['Int']['input'];
  noteContent: Scalars['ID']['input'];
  noteId: Scalars['ID']['input'];
  selectedText: Scalars['String']['input'];
  startInText: Scalars['Int']['input'];
};

/** Autogenerated return type of CreateInlineComment. */
export type CreateInlineCommentPayload = {
  __typename?: 'CreateInlineCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  comment: InlineComment;
};

/** Autogenerated input type of CreateNote */
export type CreateNoteInput = {
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   * Note that the contributors still include the user who executes this mutation in order to avoid spoofing.
   *
   */
  authorId?: InputMaybe<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  coediting: Scalars['Boolean']['input'];
  content: Scalars['String']['input'];
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  folders?: InputMaybe<Array<FolderInput>>;
  groupIds: Array<Scalars['ID']['input']>;
  /** The time when the note is published. If `draft: true` is specified, the param is ignored. */
  publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateNote. */
export type CreateNotePayload = {
  __typename?: 'CreateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** Autogenerated input type of CreateNoteTemplate */
export type CreateNoteTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  coediting: Scalars['Boolean']['input'];
  content: Scalars['String']['input'];
  folders?: InputMaybe<Array<FolderInput>>;
  groupIds: Array<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  title: Scalars['String']['input'];
};

/** Autogenerated return type of CreateNoteTemplate. */
export type CreateNoteTemplatePayload = {
  __typename?: 'CreateNoteTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  noteTemplate: NoteTemplate;
};

/** Autogenerated input type of CreateReviewableDraftComment */
export type CreateReviewableDraftCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  content: Scalars['String']['input'];
  reviewableDraftId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateReviewableDraftComment. */
export type CreateReviewableDraftCommentPayload = {
  __typename?: 'CreateReviewableDraftCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  comment: ReviewableDraftComment;
};

/** Autogenerated input type of CreateSummaryNote */
export type CreateSummaryNoteInput = {
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   *
   */
  authorEmail: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** This text is summarized by the AI and stored in the body of the article. */
  content: Scalars['String']['input'];
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  /** This text is saved at the end of the body text. */
  endContent?: InputMaybe<Scalars['String']['input']>;
  folders?: InputMaybe<Array<FolderInput>>;
  /** This text is saved at the beginning of the body text. */
  preContent?: InputMaybe<Scalars['String']['input']>;
  /** The time when the note is published. */
  publishedAt?: InputMaybe<Scalars['DateTime']['input']>;
  slackChannelId: Scalars['String']['input'];
  slackThreadTs: Scalars['String']['input'];
};

/** Autogenerated return type of CreateSummaryNote. */
export type CreateSummaryNotePayload = {
  __typename?: 'CreateSummaryNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** Autogenerated input type of CreateSynonymGroup */
export type CreateSynonymGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  words: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateSynonymGroup. */
export type CreateSynonymGroupPayload = {
  __typename?: 'CreateSynonymGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateUserList */
export type CreateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** Autogenerated return type of CreateUserList. */
export type CreateUserListPayload = {
  __typename?: 'CreateUserListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  userList: UserList;
};

/** The Custom Emoji type */
export type CustomEmoji = Node & {
  __typename?: 'CustomEmoji';
  createUser: User;
  createdAt: Scalars['DateTime']['output'];
  emojiCode: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  imageUrl: Scalars['String']['output'];
};

/** The connection type for CustomEmoji. */
export type CustomEmojiConnection = {
  __typename?: 'CustomEmojiConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomEmojiEdge>>>;
  /** A list of nodes. */
  nodes: Array<CustomEmoji>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CustomEmojiEdge = {
  __typename?: 'CustomEmojiEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomEmoji>;
};

/** A dashboard of a group */
export type Dashboard = Node & {
  __typename?: 'Dashboard';
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  group: Group;
  id: Scalars['ID']['output'];
  seqNumber: Scalars['Int']['output'];
  title?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

/** Autogenerated input type of DeleteAttachmentFiles */
export type DeleteAttachmentFilesInput = {
  attachmentIds: Array<Scalars['ID']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DeleteAttachmentFiles. */
export type DeleteAttachmentFilesPayload = {
  __typename?: 'DeleteAttachmentFilesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteAttachment */
export type DeleteAttachmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteAttachment. */
export type DeleteAttachmentPayload = {
  __typename?: 'DeleteAttachmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteComment */
export type DeleteCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteComment. */
export type DeleteCommentPayload = {
  __typename?: 'DeleteCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteCommentReply */
export type DeleteCommentReplyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteCommentReply. */
export type DeleteCommentReplyPayload = {
  __typename?: 'DeleteCommentReplyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteCustomEmoji */
export type DeleteCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  customEmojiId: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteCustomEmoji. */
export type DeleteCustomEmojiPayload = {
  __typename?: 'DeleteCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteNote */
export type DeleteNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteNote. */
export type DeleteNotePayload = {
  __typename?: 'DeleteNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteNoteVersion */
export type DeleteNoteVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteNoteVersion. */
export type DeleteNoteVersionPayload = {
  __typename?: 'DeleteNoteVersionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteSynonymGroup */
export type DeleteSynonymGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteSynonymGroup. */
export type DeleteSynonymGroupPayload = {
  __typename?: 'DeleteSynonymGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DeleteUserList */
export type DeleteUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteUserList. */
export type DeleteUserListPayload = {
  __typename?: 'DeleteUserListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DetachNoteFromFolder */
export type DetachNoteFromFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  folder: FolderInput;
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of DetachNoteFromFolder. */
export type DetachNoteFromFolderPayload = {
  __typename?: 'DetachNoteFromFolderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  detachedFolder: Folder;
  note: Note;
};

/** Autogenerated input type of DisableCollabModeStartDialog */
export type DisableCollabModeStartDialogInput = {
  account: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** If specified, it will be used in preference to `account` */
  userId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of DisableCollabModeStartDialog. */
export type DisableCollabModeStartDialogPayload = {
  __typename?: 'DisableCollabModeStartDialogPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

/** Autogenerated input type of DisableDraftReview */
export type DisableDraftReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of DisableDraftReview. */
export type DisableDraftReviewPayload = {
  __typename?: 'DisableDraftReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  reviewableDraft: ReviewableDraft;
};

/** Autogenerated input type of DisableOutgoingWebhook */
export type DisableOutgoingWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DisableOutgoingWebhook. */
export type DisableOutgoingWebhookPayload = {
  __typename?: 'DisableOutgoingWebhookPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  outgoingWebhook: OutgoingWebhook;
};

/** Autogenerated input type of DisableSharedNoteCommentsFeature */
export type DisableSharedNoteCommentsFeatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DisableSharedNoteCommentsFeature. */
export type DisableSharedNoteCommentsFeaturePayload = {
  __typename?: 'DisableSharedNoteCommentsFeaturePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DisableSharedNotesFeature */
export type DisableSharedNotesFeatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of DisableSharedNotesFeature. */
export type DisableSharedNotesFeaturePayload = {
  __typename?: 'DisableSharedNotesFeaturePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DisableUser */
export type DisableUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DisableUser. */
export type DisableUserPayload = {
  __typename?: 'DisableUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of DisableUsers */
export type DisableUsersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  ids: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of DisableUsers. */
export type DisableUsersPayload = {
  __typename?: 'DisableUsersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of EnableCollabModeStartDialog */
export type EnableCollabModeStartDialogInput = {
  account: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** If specified, it will be used in preference to `account` */
  userId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of EnableCollabModeStartDialog. */
export type EnableCollabModeStartDialogPayload = {
  __typename?: 'EnableCollabModeStartDialogPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  user: User;
};

/** Autogenerated input type of EnableDraftReview */
export type EnableDraftReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of EnableDraftReview. */
export type EnableDraftReviewPayload = {
  __typename?: 'EnableDraftReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  reviewableDraft: ReviewableDraft;
};

/** Autogenerated input type of EnableOutgoingWebhook */
export type EnableOutgoingWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of EnableOutgoingWebhook. */
export type EnableOutgoingWebhookPayload = {
  __typename?: 'EnableOutgoingWebhookPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  outgoingWebhook: OutgoingWebhook;
};

/** Autogenerated input type of EnableSharedNoteCommentsFeature */
export type EnableSharedNoteCommentsFeatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of EnableSharedNoteCommentsFeature. */
export type EnableSharedNoteCommentsFeaturePayload = {
  __typename?: 'EnableSharedNoteCommentsFeaturePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of EnableSharedNotesFeature */
export type EnableSharedNotesFeatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of EnableSharedNotesFeature. */
export type EnableSharedNotesFeaturePayload = {
  __typename?: 'EnableSharedNotesFeaturePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** External URL's data for rich text editor. */
export type ExternalUrlData = {
  __typename?: 'ExternalUrlData';
  description?: Maybe<Scalars['String']['output']>;
  favicon?: Maybe<Scalars['String']['output']>;
  og?: Maybe<OpenGraph>;
  title?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of ExtractNoteTextSelectionMarkdownRanges */
export type ExtractNoteTextSelectionMarkdownRangesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  noteContent: Scalars['String']['input'];
  noteTextSelections: Array<NoteTextSelectionInput>;
};

/** Autogenerated return type of ExtractNoteTextSelectionMarkdownRanges. */
export type ExtractNoteTextSelectionMarkdownRangesPayload = {
  __typename?: 'ExtractNoteTextSelectionMarkdownRangesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  noteTextSelections: NoteTextSelectionConnection;
};


/** Autogenerated return type of ExtractNoteTextSelectionMarkdownRanges. */
export type ExtractNoteTextSelectionMarkdownRangesPayloadNoteTextSelectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ExtractNoteTextSelectionTextRanges */
export type ExtractNoteTextSelectionTextRangesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  noteContent: Scalars['String']['input'];
  noteTextSelections: Array<NoteTextSelectionInput>;
};

/** Autogenerated return type of ExtractNoteTextSelectionTextRanges. */
export type ExtractNoteTextSelectionTextRangesPayload = {
  __typename?: 'ExtractNoteTextSelectionTextRangesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  noteTextSelections: NoteTextSelectionConnection;
};


/** Autogenerated return type of ExtractNoteTextSelectionTextRanges. */
export type ExtractNoteTextSelectionTextRangesPayloadNoteTextSelectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A section of a feed, which includes notes in a folder */
export type FeedFolderParcel = {
  __typename?: 'FeedFolderParcel';
  date: Scalars['DateTime']['output'];
  folder: Folder;
  notes: NoteConnection;
};


/** A section of a feed, which includes notes in a folder */
export type FeedFolderParcelNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The kind to indicate what the feed is */
export enum FeedKind {
  All = 'ALL',
  Group = 'GROUP',
  MyFeed = 'MY_FEED'
}

/** The kind to indicate what the feed is */
export enum FeedKindWithoutGroup {
  All = 'ALL',
  MyFeed = 'MY_FEED'
}

/** A section of feed, which includes a note */
export type FeedNote = {
  __typename?: 'FeedNote';
  date: Scalars['DateTime']['output'];
  note: Note;
};

/** A section of feed, which includes one or more notes */
export type FeedSection = FeedFolderParcel | FeedNote | FeedUserParcel;

export type FeedSectionSimpleConnection = {
  __typename?: 'FeedSectionSimpleConnection';
  edges: Array<FeedSectionSimpleEdge>;
  pageInfo: FeedSectionSimplePageInfo;
};

export type FeedSectionSimpleEdge = {
  __typename?: 'FeedSectionSimpleEdge';
  node: FeedSection;
};

export type FeedSectionSimplePageInfo = {
  __typename?: 'FeedSectionSimplePageInfo';
  endCursor: Scalars['String']['output'];
  hasNextPage?: Maybe<Scalars['Boolean']['output']>;
};

/** A section of feed, which includes notes written by a user */
export type FeedUserParcel = {
  __typename?: 'FeedUserParcel';
  date: Scalars['DateTime']['output'];
  notes: NoteConnection;
  user: User;
};


/** A section of feed, which includes notes written by a user */
export type FeedUserParcelNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type Folder = Node & {
  __typename?: 'Folder';
  activeChildrenCount: Scalars['Int']['output'];
  aliveNotesCount: Scalars['Int']['output'];
  alivePinnedNotesCount: Scalars['Int']['output'];
  archivedAt?: Maybe<Scalars['DateTime']['output']>;
  canBeManaged: Scalars['Boolean']['output'];
  components: Array<Folder>;
  createdAt: Scalars['DateTime']['output'];
  descendantNotes: NoteConnection;
  fixedPath: Scalars['String']['output'];
  folders: FolderConnection;
  fullName: Scalars['String']['output'];
  group: Group;
  id: Scalars['ID']['output'];
  lastModifiedAt?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  newNotePath: Scalars['String']['output'];
  notes: NoteConnection;
  parent?: Maybe<Folder>;
  path: Scalars['String']['output'];
  pinnedNotes: NoteConnection;
  unarchivableDescendantNoteTitles: Array<Scalars['String']['output']>;
  unarchivableDescendantNotes: NoteConnection;
  updatedAt: Scalars['DateTime']['output'];
};


export type FolderDescendantNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type FolderFoldersArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type FolderNotesArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyCoediting?: InputMaybe<Scalars['Boolean']['input']>;
  orderBy?: InputMaybe<NoteOrder>;
};


export type FolderPinnedNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type FolderUnarchivableDescendantNoteTitlesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type FolderUnarchivableDescendantNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for Folder. */
export type FolderConnection = {
  __typename?: 'FolderConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FolderEdge>>>;
  /** A list of nodes. */
  nodes: Array<Folder>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type FolderEdge = {
  __typename?: 'FolderEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Folder>;
};

/** Input folder with group struct */
export type FolderInput = {
  folderName: Scalars['String']['input'];
  groupId: Scalars['ID']['input'];
};

export type Group = Node & {
  __typename?: 'Group';
  archivedAt?: Maybe<Scalars['DateTime']['output']>;
  /** @deprecated This field will be replaced with canBeJoinedBySelf */
  canBeJoined: Scalars['Boolean']['output'];
  canBeJoinedBySelf: Scalars['Boolean']['output'];
  canBeManaged: Scalars['Boolean']['output'];
  coverImage: GroupCoverImage;
  coverImageKey?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  dashboards: Array<Dashboard>;
  /** @deprecated Provided only for legacy frontend. */
  databaseId: Scalars['Int']['output'];
  description: Scalars['String']['output'];
  feedUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
  folders: FolderConnection;
  id: Scalars['ID']['output'];
  isArchived: Scalars['Boolean']['output'];
  isDefault: Scalars['Boolean']['output'];
  isJoined: Scalars['Boolean']['output'];
  isPrivate: Scalars['Boolean']['output'];
  isVisibilityChangeable: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  notes: NoteConnection;
  path: Scalars['String']['output'];
  pinnedNotes: Array<Note>;
  todayContributors: UserConnection;
  trendNotes: NoteConnection;
  updatedAt: Scalars['DateTime']['output'];
  userListMembers: UserListGroupMemberConnection;
  users: UserConnection;
};


export type GroupCoverImageArgs = {
  density: Scalars['Int']['input'];
  size: GroupCoverImageSize;
};


export type GroupFoldersArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  parentFolderId?: InputMaybe<Scalars['ID']['input']>;
  parentFolderIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  withChildren?: InputMaybe<Scalars['Boolean']['input']>;
};


export type GroupNotesArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyNotAttachedFolder?: InputMaybe<Scalars['Boolean']['input']>;
  orderBy?: InputMaybe<NoteOrder>;
};


export type GroupTodayContributorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupTrendNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupUserListMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type GroupUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Abilities for groups. */
export enum GroupAbility {
  AssociationManageable = 'ASSOCIATION_MANAGEABLE',
  Readable = 'READABLE'
}

/** A group announcement */
export type GroupAnnouncement = Node & {
  __typename?: 'GroupAnnouncement';
  group: Group;
  id: Scalars['ID']['output'];
  referentFolders: GroupAnnouncementFolderConnection;
};


/** A group announcement */
export type GroupAnnouncementReferentFoldersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type GroupAnnouncementFolder = {
  __typename?: 'GroupAnnouncementFolder';
  createdAt: Scalars['DateTime']['output'];
  folder: Folder;
  groupAnnouncement: GroupAnnouncement;
  id: Scalars['ID']['output'];
  numberOfLines: Scalars['Int']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for GroupAnnouncementFolder. */
export type GroupAnnouncementFolderConnection = {
  __typename?: 'GroupAnnouncementFolderConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupAnnouncementFolderEdge>>>;
  /** A list of nodes. */
  nodes: Array<GroupAnnouncementFolder>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type GroupAnnouncementFolderEdge = {
  __typename?: 'GroupAnnouncementFolderEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupAnnouncementFolder>;
};

/** Attributes for creating or updating a GroupAnnouncement::Folder */
export type GroupAnnouncementFolderInput = {
  folderId: Scalars['ID']['input'];
  numberOfLines: Scalars['Int']['input'];
};

/** The connection type for Group. */
export type GroupConnection = {
  __typename?: 'GroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  /** A list of nodes. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** Cover image of a group */
export type GroupCoverImage = {
  __typename?: 'GroupCoverImage';
  density: Scalars['Int']['output'];
  height: Scalars['Int']['output'];
  url: Scalars['String']['output'];
  width: Scalars['Int']['output'];
};

/** The size class of group cover images */
export enum GroupCoverImageSize {
  Large = 'LARGE',
  Medium = 'MEDIUM'
}

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: 'GroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Group>;
};

export type GroupMember = Node & {
  __typename?: 'GroupMember';
  groupId: Scalars['ID']['output'];
  /** ID of the object. */
  id: Scalars['ID']['output'];
  role: GroupMemberRole;
  userId: Scalars['ID']['output'];
};

/** The role of group member */
export enum GroupMemberRole {
  Admin = 'admin',
  Editor = 'editor',
  Reader = 'reader'
}

/** The type of group */
export enum GroupType {
  Private = 'private',
  PrivateVisibilityNone = 'private_visibility_none',
  Public = 'public',
  PublicOperationRestricted = 'public_operation_restricted'
}

/** Autogenerated return type of HealthChecked. */
export type HealthCheckedPayload = {
  __typename?: 'HealthCheckedPayload';
  status: Scalars['String']['output'];
};

/** Autogenerated input type of IgnoreMultiFactorAuthnForMultipleUsers */
export type IgnoreMultiFactorAuthnForMultipleUsersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  userIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of IgnoreMultiFactorAuthnForMultipleUsers. */
export type IgnoreMultiFactorAuthnForMultipleUsersPayload = {
  __typename?: 'IgnoreMultiFactorAuthnForMultipleUsersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of IgnoreMultiFactorAuthn */
export type IgnoreMultiFactorAuthnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of IgnoreMultiFactorAuthn. */
export type IgnoreMultiFactorAuthnPayload = {
  __typename?: 'IgnoreMultiFactorAuthnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** A user representation from importable services */
export type ImportableUser = {
  __typename?: 'ImportableUser';
  account: Scalars['String']['output'];
  avatarUrl: Scalars['String']['output'];
  realName: Scalars['String']['output'];
};

/** A inline comment that belongs to a Note */
export type InlineComment = CommentInterface & Node & {
  __typename?: 'InlineComment';
  anchor: Scalars['String']['output'];
  author: User;
  canBeLiked: Scalars['Boolean']['output'];
  canBeResolved: Scalars['Boolean']['output'];
  canBeUpdated: Scalars['Boolean']['output'];
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  contentSummaryHtml: Scalars['String']['output'];
  contentUpdatedAt: Scalars['DateTime']['output'];
  contributors: UserConnection;
  createdAt: Scalars['DateTime']['output'];
  editedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  isEdited: Scalars['Boolean']['output'];
  isLikedByCurrentUser: Scalars['Boolean']['output'];
  isResolved: Scalars['Boolean']['output'];
  likers: UserConnection;
  noteTextSelection?: Maybe<NoteTextSelection>;
  path: Scalars['String']['output'];
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  replies: CommentReplyConnection;
  resolvedAt?: Maybe<Scalars['DateTime']['output']>;
  resolvedBy?: Maybe<User>;
  updatedAt: Scalars['DateTime']['output'];
};


/** A inline comment that belongs to a Note */
export type InlineCommentContributorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributorOrder>;
};


/** A inline comment that belongs to a Note */
export type InlineCommentLikersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A inline comment that belongs to a Note */
export type InlineCommentRepliesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for InlineComment. */
export type InlineCommentConnection = {
  __typename?: 'InlineCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InlineCommentEdge>>>;
  /** A list of nodes. */
  nodes: Array<InlineComment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type InlineCommentEdge = {
  __typename?: 'InlineCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<InlineComment>;
};

/** Internal URL's data for rich text editor. */
export type InternalUrlData = {
  __typename?: 'InternalUrlData';
  avatar1xUrl?: Maybe<Scalars['String']['output']>;
  avatar2xUrl?: Maybe<Scalars['String']['output']>;
  isCoediting?: Maybe<Scalars['Boolean']['output']>;
  linkType: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

/** Message hints that suggest what happens in sending invitations */
export enum InvitationHint {
  /** They is already a member of the team. Nothing is done. */
  AlreadyJoined = 'ALREADY_JOINED',
  /** The invitation has been sent to them. */
  Invited = 'INVITED',
  /** Those who is disabled before is now re-enabled. Nothing is done. */
  ReEnabled = 'RE_ENABLED'
}

/** Autogenerated input type of Invite */
export type InviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  /** The group IDs to invite */
  groupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** This message is displayed in the mail content of the user who received the invitation. */
  message?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Role>;
};

/** Autogenerated return type of Invite. */
export type InvitePayload = {
  __typename?: 'InvitePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  email: Scalars['String']['output'];
  hint: InvitationHint;
  role: Role;
};

/** Autogenerated input type of JoinGroup */
export type JoinGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of JoinGroup. */
export type JoinGroupPayload = {
  __typename?: 'JoinGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

/** Autogenerated input type of JoinGroupUsingUserList */
export type JoinGroupUsingUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  role?: InputMaybe<GroupMemberRole>;
  userListId: Scalars['ID']['input'];
};

/** Autogenerated return type of JoinGroupUsingUserList. */
export type JoinGroupUsingUserListPayload = {
  __typename?: 'JoinGroupUsingUserListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of LeaveGroup */
export type LeaveGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of LeaveGroup. */
export type LeaveGroupPayload = {
  __typename?: 'LeaveGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

/** Autogenerated input type of LeaveGroupUsingUserList */
export type LeaveGroupUsingUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  userListId: Scalars['ID']['input'];
};

/** Autogenerated return type of LeaveGroupUsingUserList. */
export type LeaveGroupUsingUserListPayload = {
  __typename?: 'LeaveGroupUsingUserListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of Like */
export type LikeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  likableId: Scalars['ID']['input'];
};

/** Autogenerated return type of Like. */
export type LikePayload = {
  __typename?: 'LikePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  likers: UserConnection;
};


/** Autogenerated return type of Like. */
export type LikePayloadLikersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Types of main purpose of using Kibela */
export enum MainPurpose {
  Announcements = 'ANNOUNCEMENTS',
  Communication = 'COMMUNICATION',
  Knowledge = 'KNOWLEDGE',
  Manual = 'MANUAL',
  Others = 'OTHERS',
  Portal = 'PORTAL'
}

/** Autogenerated input type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of MarkNotificationsAsRead. */
export type MarkNotificationsAsReadPayload = {
  __typename?: 'MarkNotificationsAsReadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of MarkServiceNotificationsAsRead */
export type MarkServiceNotificationsAsReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  serviceNotificationIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of MarkServiceNotificationsAsRead. */
export type MarkServiceNotificationsAsReadPayload = {
  __typename?: 'MarkServiceNotificationsAsReadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of MoveNoteToAnotherFolder */
export type MoveNoteToAnotherFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Set folderName field to empty string if the note is not attached to any folder */
  fromFolder: FolderInput;
  noteId: Scalars['ID']['input'];
  toFolder: FolderInput;
};

/** Autogenerated return type of MoveNoteToAnotherFolder. */
export type MoveNoteToAnotherFolderPayload = {
  __typename?: 'MoveNoteToAnotherFolderPayload';
  afterFolder: Folder;
  /** Null when fromFolder.folderName argument is empty string */
  beforeFolder?: Maybe<Folder>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String']['output'];
  note: Note;
};

/** Autogenerated input type of MoveNoteToAnotherGroup */
export type MoveNoteToAnotherGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fromFolderId?: InputMaybe<Scalars['ID']['input']>;
  fromGroupId: Scalars['ID']['input'];
  noteId: Scalars['ID']['input'];
  toGroupId: Scalars['ID']['input'];
};

/** Autogenerated return type of MoveNoteToAnotherGroup. */
export type MoveNoteToAnotherGroupPayload = {
  __typename?: 'MoveNoteToAnotherGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** The top-level mutation type to mutate resources */
export type Mutation = {
  __typename?: 'Mutation';
  /** Adds users to user list */
  addUsersToUserList: AddUsersToUserListPayload;
  /** Archive a folder */
  archiveFolder: ArchiveFolderPayload;
  /** Archive folders */
  archiveFolders: ArchiveFoldersPayload;
  /** Archive a group */
  archiveGroup: ArchiveGroupPayload;
  /** Archive a note */
  archiveNote: ArchiveNotePayload;
  /** Archive notes */
  archiveNotes: ArchiveNotesPayload;
  /** Attach a note to folder */
  attachNoteToFolder: AttachNoteToFolderPayload;
  /** Change group permission of user list */
  changeGroupPermissionOfUserList: ChangeGroupPermissionOfUserListPayload;
  /** Close an announcement */
  closeAnnouncement: CloseAnnouncementPayload;
  /** It creates an access token */
  createAccessToken: CreateAccessTokenPayload;
  /** Create an AI review */
  createAiReview: CreateAiReviewPayload;
  /** Creates a comment */
  createComment: CreateCommentPayload;
  /** Creates a reply to the comment */
  createCommentReply: CreateCommentReplyPayload;
  /** Creates a custom emoji */
  createCustomEmoji: CreateCustomEmojiPayload;
  /** It creates a disabled user with the specified profile. It requires  **administrative privileges**. */
  createDisabledUser: CreateDisabledUserPayload;
  /** Creates a folder */
  createFolder: CreateFolderPayload;
  /** Pin note to a folder */
  createFolderPin: CreateFolderPinPayload;
  /**
   * Creates a group. The current user is added as a group member.
   *
   * It may fail with the `UPGRADE_REQUIRED` error code if the plan is free and there is no room to create a new group.
   *
   */
  createGroup: CreateGroupPayload;
  /** Creates a group announcement */
  createGroupAnnouncement: CreateGroupAnnouncementPayload;
  /** Pin note to a group */
  createGroupPin: CreateGroupPinPayload;
  /** Creates a inline comment */
  createInlineComment: CreateInlineCommentPayload;
  /** Creates a note */
  createNote: CreateNotePayload;
  /** Create a note template */
  createNoteTemplate: CreateNoteTemplatePayload;
  /** Creates a draft review comment */
  createReviewableDraftComment: CreateReviewableDraftCommentPayload;
  /** Create a summary note */
  createSummaryNote: CreateSummaryNotePayload;
  /** It creates a synonym group */
  createSynonymGroup: CreateSynonymGroupPayload;
  /** Creates a user list */
  createUserList: CreateUserListPayload;
  /**
   * It deletes an attachment that is owned by the current user.
   * @deprecated This feature is for internal use only.
   */
  deleteAttachment: DeleteAttachmentPayload;
  /** It deletes uploaded attachment files that is owned by the current user. */
  deleteAttachmentFiles: DeleteAttachmentFilesPayload;
  /** Deletes a comment */
  deleteComment: DeleteCommentPayload;
  /** Deletes a reply to comment */
  deleteCommentReply: DeleteCommentReplyPayload;
  /** Deletes a custom emoji */
  deleteCustomEmoji: DeleteCustomEmojiPayload;
  /** Deletes a note */
  deleteNote: DeleteNotePayload;
  /** Deletes a note version */
  deleteNoteVersion: DeleteNoteVersionPayload;
  /** It deletes a synonym group */
  deleteSynonymGroup: DeleteSynonymGroupPayload;
  /** Remove a user list */
  deleteUserList: DeleteUserListPayload;
  /** Detach a note from folder */
  detachNoteFromFolder: DetachNoteFromFolderPayload;
  /** Disable the confirmation dialog appears when the user starts the collaboration mode */
  disableCollabModeStartDialog: DisableCollabModeStartDialogPayload;
  /** Disable draft review of the specified note. */
  disableDraftReview: DisableDraftReviewPayload;
  /** Disable Outgoing Webhook */
  disableOutgoingWebhook: DisableOutgoingWebhookPayload;
  /** Disable shared note comments feature in the team settings */
  disableSharedNoteCommentsFeature: DisableSharedNoteCommentsFeaturePayload;
  /** Disable shared notes feature in the team settings */
  disableSharedNotesFeature: DisableSharedNotesFeaturePayload;
  /** Disables a user. The current user must be an *admin* or *owner*. */
  disableUser: DisableUserPayload;
  /** Disables multiple users. The current user must be an *admin* or *owner*. */
  disableUsers: DisableUsersPayload;
  /** Enable the confirmation dialog appears when the user starts the collaboration mode */
  enableCollabModeStartDialog: EnableCollabModeStartDialogPayload;
  /** Enable draft review of the specified note. */
  enableDraftReview: EnableDraftReviewPayload;
  /** Enable Outgoing Webhook */
  enableOutgoingWebhook: EnableOutgoingWebhookPayload;
  /** Enable shared note comments feature in the team settings */
  enableSharedNoteCommentsFeature: EnableSharedNoteCommentsFeaturePayload;
  /** Enable shared notes feature in the team settings */
  enableSharedNotesFeature: EnableSharedNotesFeaturePayload;
  /** Extract ranges of note text selection in markdown */
  extractNoteTextSelectionMarkdownRanges: ExtractNoteTextSelectionMarkdownRangesPayload;
  /** Extract ranges of note text selection in text */
  extractNoteTextSelectionTextRanges: ExtractNoteTextSelectionTextRangesPayload;
  /** Ignore multi factor authn for 1 day. */
  ignoreMultiFactorAuthn: IgnoreMultiFactorAuthnPayload;
  /** Ignore multi factor authn for 1 day. */
  ignoreMultiFactorAuthnForMultipleUsers: IgnoreMultiFactorAuthnForMultipleUsersPayload;
  /**
   * Invites a user with their email.
   * Only owners and admins can invite users.
   *
   * It may fail with the `UPGRADE_REQUIRED` error code if the plan is free and there is no room to create a new user.
   *
   */
  invite: InvitePayload;
  /** Join a group */
  joinGroup: JoinGroupPayload;
  /** Join a group using user list */
  joinGroupUsingUserList: JoinGroupUsingUserListPayload;
  /** Leave a group */
  leaveGroup: LeaveGroupPayload;
  /** Leave a group using user list */
  leaveGroupUsingUserList: LeaveGroupUsingUserListPayload;
  /** Like a note or comment */
  like: LikePayload;
  markNotificationsAsRead: MarkNotificationsAsReadPayload;
  markServiceNotificationsAsRead: MarkServiceNotificationsAsReadPayload;
  /** Move a note to another folder */
  moveNoteToAnotherFolder: MoveNoteToAnotherFolderPayload;
  /** Move a note to another group */
  moveNoteToAnotherGroup: MoveNoteToAnotherGroupPayload;
  /** Remove pinned note from a folder */
  removeFolderPin: RemoveFolderPinPayload;
  /** Remove pinned note from a group */
  removeGroupPin: RemoveGroupPinPayload;
  /** Remove users from user list */
  removeUsersFromUserList: RemoveUsersFromUserListPayload;
  /** Request attachment to attachment file preview conversion */
  requestAttachmentConversion: RequestAttachmentConversionPayload;
  /** Resolve an inline comment */
  resolveInlineComment: ResolveInlineCommentPayload;
  /** Restore an archived folder */
  restoreFolder: RestoreFolderPayload;
  /** Restore an archived group */
  restoreGroup: RestoreGroupPayload;
  /** Restore an archived note */
  restoreNote: RestoreNotePayload;
  /** It revokes an access token; the secret `token` is available after the access token is revoked. */
  revokeAccessToken: RevokeAccessTokenPayload;
  /** Set feed to home */
  setFeedToHome: SetFeedToHomePayload;
  /** Set group to home */
  setGroupToHome: SetGroupToHomePayload;
  /** Share specified note with outside of the team */
  shareNoteWithOutsideOfTeam: ShareNoteWithOutsideOfTeamPayload;
  /** Sort group pins */
  sortGroupPins: SortGroupPinsPayload;
  /**
   * Sync last used editor for user
   * @deprecated This is beta and internal feature.
   */
  syncUserLastUsedEditor: SyncUserLastUsedEditorPayload;
  /** Transfer notes of a group to another */
  transferGroupNotes: TransferGroupNotesPayload;
  /** Unlike a note or comment */
  unlike: UnlikePayload;
  /** Unresolve an inline comment */
  unresolveInlineComment: UnresolveInlineCommentPayload;
  /** Unshare specified note with outside of the team */
  unshareNoteWithOutsideOfTeam: UnshareNoteWithOutsideOfTeamPayload;
  /** Unwatch a note */
  unwatchNote: UnwatchNotePayload;
  /** It updates attributes of an access token */
  updateAccessToken: UpdateAccessTokenPayload;
  /** Updates a comment */
  updateComment: UpdateCommentPayload;
  /** Updates a reply to comment */
  updateCommentReply: UpdateCommentReplyPayload;
  /** Update the content of dashboard without conflict-checking. Use updateDashboardContent to check conflict. */
  updateDashboard: UpdateDashboardPayload;
  /** Update the content of a dashboard with simple conflict-checking */
  updateDashboardContent: UpdateDashboardContentPayload;
  /** Update name of a folder */
  updateFolderName: UpdateFolderNamePayload;
  /** Update the folder parent */
  updateFolderParent: UpdateFolderParentPayload;
  /** Update a group */
  updateGroup: UpdateGroupPayload;
  /** Updates a group announcement */
  updateGroupAnnouncement: UpdateGroupAnnouncementPayload;
  /** Update member of group */
  updateGroupMember: UpdateGroupMemberPayload;
  /** Update a note, trying to merge conflicts with the 3-way diff algorithm */
  updateNote: UpdateNotePayload;
  /** Update the content of a note with conflict-checking, trying 3-way merging on conflicts */
  updateNoteContent: UpdateNoteContentPayload;
  /** Replace all groups associated with the specified note */
  updateNoteGroups: UpdateNoteGroupsPayload;
  /** Update a note template */
  updateNoteTemplate: UpdateNoteTemplatePayload;
  /** Update title of a note */
  updateNoteTitle: UpdateNoteTitlePayload;
  /** Update SAML2 single sign-on setting */
  updateSaml2SsoSetting: UpdateSaml2SsoSettingPayload;
  /** Update a summary note */
  updateSummaryNote: UpdateSummaryNotePayload;
  /** It updates a synonym group */
  updateSynonymGroup: UpdateSynonymGroupPayload;
  /** Update team setting */
  updateTeamSetting: UpdateTeamSettingPayload;
  /** Update a user list */
  updateUserList: UpdateUserListPayload;
  /** Update notification setting of current user */
  updateUserNotificationSetting: UpdateUserNotificationSettingPayload;
  /** Update groups for users */
  updateUsersGroups: UpdateUsersGroupsPayload;
  /** Upload an attachment as files in markdown contents, avatars, or cover images. */
  uploadAttachment: UploadAttachmentPayload;
  /** Upload an attachment as files in markdown contents, avatars, or cover images. */
  uploadAttachmentWithDataUrl: UploadAttachmentWithDataUrlPayload;
  /** Watch a note */
  watchNote: WatchNotePayload;
};


/** The top-level mutation type to mutate resources */
export type MutationAddUsersToUserListArgs = {
  input: AddUsersToUserListInput;
};


/** The top-level mutation type to mutate resources */
export type MutationArchiveFolderArgs = {
  input: ArchiveFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationArchiveFoldersArgs = {
  input: ArchiveFoldersInput;
};


/** The top-level mutation type to mutate resources */
export type MutationArchiveGroupArgs = {
  input: ArchiveGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationArchiveNoteArgs = {
  input: ArchiveNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationArchiveNotesArgs = {
  input: ArchiveNotesInput;
};


/** The top-level mutation type to mutate resources */
export type MutationAttachNoteToFolderArgs = {
  input: AttachNoteToFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationChangeGroupPermissionOfUserListArgs = {
  input: ChangeGroupPermissionOfUserListInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCloseAnnouncementArgs = {
  input: CloseAnnouncementInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateAccessTokenArgs = {
  input: CreateAccessTokenInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateAiReviewArgs = {
  input: CreateAiReviewInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateCommentArgs = {
  input: CreateCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateCommentReplyArgs = {
  input: CreateCommentReplyInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateCustomEmojiArgs = {
  input: CreateCustomEmojiInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateDisabledUserArgs = {
  input: CreateDisabledUserInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateFolderArgs = {
  input: CreateFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateFolderPinArgs = {
  input: CreateFolderPinInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateGroupAnnouncementArgs = {
  input: CreateGroupAnnouncementInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateGroupPinArgs = {
  input: CreateGroupPinInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateInlineCommentArgs = {
  input: CreateInlineCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateNoteArgs = {
  input: CreateNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateNoteTemplateArgs = {
  input: CreateNoteTemplateInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateReviewableDraftCommentArgs = {
  input: CreateReviewableDraftCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateSummaryNoteArgs = {
  input: CreateSummaryNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateSynonymGroupArgs = {
  input: CreateSynonymGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateUserListArgs = {
  input: CreateUserListInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteAttachmentArgs = {
  input: DeleteAttachmentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteAttachmentFilesArgs = {
  input: DeleteAttachmentFilesInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteCommentArgs = {
  input: DeleteCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteCommentReplyArgs = {
  input: DeleteCommentReplyInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteCustomEmojiArgs = {
  input: DeleteCustomEmojiInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteNoteArgs = {
  input: DeleteNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteNoteVersionArgs = {
  input: DeleteNoteVersionInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteSynonymGroupArgs = {
  input: DeleteSynonymGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteUserListArgs = {
  input: DeleteUserListInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDetachNoteFromFolderArgs = {
  input: DetachNoteFromFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableCollabModeStartDialogArgs = {
  input: DisableCollabModeStartDialogInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableDraftReviewArgs = {
  input: DisableDraftReviewInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableOutgoingWebhookArgs = {
  input: DisableOutgoingWebhookInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableSharedNoteCommentsFeatureArgs = {
  input: DisableSharedNoteCommentsFeatureInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableSharedNotesFeatureArgs = {
  input: DisableSharedNotesFeatureInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableUserArgs = {
  input: DisableUserInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableUsersArgs = {
  input: DisableUsersInput;
};


/** The top-level mutation type to mutate resources */
export type MutationEnableCollabModeStartDialogArgs = {
  input: EnableCollabModeStartDialogInput;
};


/** The top-level mutation type to mutate resources */
export type MutationEnableDraftReviewArgs = {
  input: EnableDraftReviewInput;
};


/** The top-level mutation type to mutate resources */
export type MutationEnableOutgoingWebhookArgs = {
  input: EnableOutgoingWebhookInput;
};


/** The top-level mutation type to mutate resources */
export type MutationEnableSharedNoteCommentsFeatureArgs = {
  input: EnableSharedNoteCommentsFeatureInput;
};


/** The top-level mutation type to mutate resources */
export type MutationEnableSharedNotesFeatureArgs = {
  input: EnableSharedNotesFeatureInput;
};


/** The top-level mutation type to mutate resources */
export type MutationExtractNoteTextSelectionMarkdownRangesArgs = {
  input: ExtractNoteTextSelectionMarkdownRangesInput;
};


/** The top-level mutation type to mutate resources */
export type MutationExtractNoteTextSelectionTextRangesArgs = {
  input: ExtractNoteTextSelectionTextRangesInput;
};


/** The top-level mutation type to mutate resources */
export type MutationIgnoreMultiFactorAuthnArgs = {
  input: IgnoreMultiFactorAuthnInput;
};


/** The top-level mutation type to mutate resources */
export type MutationIgnoreMultiFactorAuthnForMultipleUsersArgs = {
  input: IgnoreMultiFactorAuthnForMultipleUsersInput;
};


/** The top-level mutation type to mutate resources */
export type MutationInviteArgs = {
  input: InviteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationJoinGroupArgs = {
  input: JoinGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationJoinGroupUsingUserListArgs = {
  input: JoinGroupUsingUserListInput;
};


/** The top-level mutation type to mutate resources */
export type MutationLeaveGroupArgs = {
  input: LeaveGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationLeaveGroupUsingUserListArgs = {
  input: LeaveGroupUsingUserListInput;
};


/** The top-level mutation type to mutate resources */
export type MutationLikeArgs = {
  input: LikeInput;
};


/** The top-level mutation type to mutate resources */
export type MutationMarkNotificationsAsReadArgs = {
  input: MarkNotificationsAsReadInput;
};


/** The top-level mutation type to mutate resources */
export type MutationMarkServiceNotificationsAsReadArgs = {
  input: MarkServiceNotificationsAsReadInput;
};


/** The top-level mutation type to mutate resources */
export type MutationMoveNoteToAnotherFolderArgs = {
  input: MoveNoteToAnotherFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationMoveNoteToAnotherGroupArgs = {
  input: MoveNoteToAnotherGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRemoveFolderPinArgs = {
  input: RemoveFolderPinInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRemoveGroupPinArgs = {
  input: RemoveGroupPinInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRemoveUsersFromUserListArgs = {
  input: RemoveUsersFromUserListInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRequestAttachmentConversionArgs = {
  input: RequestAttachmentConversionInput;
};


/** The top-level mutation type to mutate resources */
export type MutationResolveInlineCommentArgs = {
  input: ResolveInlineCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRestoreFolderArgs = {
  input: RestoreFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRestoreGroupArgs = {
  input: RestoreGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRestoreNoteArgs = {
  input: RestoreNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRevokeAccessTokenArgs = {
  input: RevokeAccessTokenInput;
};


/** The top-level mutation type to mutate resources */
export type MutationSetFeedToHomeArgs = {
  input: SetFeedToHomeInput;
};


/** The top-level mutation type to mutate resources */
export type MutationSetGroupToHomeArgs = {
  input: SetGroupToHomeInput;
};


/** The top-level mutation type to mutate resources */
export type MutationShareNoteWithOutsideOfTeamArgs = {
  input: ShareNoteWithOutsideOfTeamInput;
};


/** The top-level mutation type to mutate resources */
export type MutationSortGroupPinsArgs = {
  input: SortGroupPinsInput;
};


/** The top-level mutation type to mutate resources */
export type MutationSyncUserLastUsedEditorArgs = {
  input: SyncUserLastUsedEditorInput;
};


/** The top-level mutation type to mutate resources */
export type MutationTransferGroupNotesArgs = {
  input: TransferGroupNotesInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUnlikeArgs = {
  input: UnlikeInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUnresolveInlineCommentArgs = {
  input: UnresolveInlineCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUnshareNoteWithOutsideOfTeamArgs = {
  input: UnshareNoteWithOutsideOfTeamInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUnwatchNoteArgs = {
  input: UnwatchNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateAccessTokenArgs = {
  input: UpdateAccessTokenInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateCommentArgs = {
  input: UpdateCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateCommentReplyArgs = {
  input: UpdateCommentReplyInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateDashboardArgs = {
  input: UpdateDashboardInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateDashboardContentArgs = {
  input: UpdateDashboardContentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateFolderNameArgs = {
  input: UpdateFolderNameInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateFolderParentArgs = {
  input: UpdateFolderParentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateGroupAnnouncementArgs = {
  input: UpdateGroupAnnouncementInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateGroupMemberArgs = {
  input: UpdateGroupMemberInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteArgs = {
  input: UpdateNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteContentArgs = {
  input: UpdateNoteContentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteGroupsArgs = {
  input: UpdateNoteGroupsInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteTemplateArgs = {
  input: UpdateNoteTemplateInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteTitleArgs = {
  input: UpdateNoteTitleInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateSaml2SsoSettingArgs = {
  input: UpdateSaml2SsoSettingInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateSummaryNoteArgs = {
  input: UpdateSummaryNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateSynonymGroupArgs = {
  input: UpdateSynonymGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateTeamSettingArgs = {
  input: UpdateTeamSettingInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateUserListArgs = {
  input: UpdateUserListInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateUserNotificationSettingArgs = {
  input: UpdateUserNotificationSettingInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateUsersGroupsArgs = {
  input: UpdateUsersGroupsInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUploadAttachmentArgs = {
  input: UploadAttachmentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUploadAttachmentWithDataUrlArgs = {
  input: UploadAttachmentWithDataUrlInput;
};


/** The top-level mutation type to mutate resources */
export type MutationWatchNoteArgs = {
  input: WatchNoteInput;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID']['output'];
};

/** The Note type */
export type Note = Node & {
  __typename?: 'Note';
  attachments: AttachmentConnection;
  author?: Maybe<User>;
  canBeArchived: Scalars['Boolean']['output'];
  canBeCommented: Scalars['Boolean']['output'];
  canBeDestroyed: Scalars['Boolean']['output'];
  canBeLiked: Scalars['Boolean']['output'];
  canBeUpdated: Scalars['Boolean']['output'];
  /** @deprecated This is beta and internal feature. */
  coeditRoom?: Maybe<CoeditRoom>;
  coediting: Scalars['Boolean']['output'];
  comments: CommentConnection;
  commentsCount: Scalars['Int']['output'];
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  contentSummaryHtml: Scalars['String']['output'];
  contentTocHtml: Scalars['String']['output'];
  contentUpdatedAt: Scalars['DateTime']['output'];
  contributors: UserConnection;
  createdAt: Scalars['DateTime']['output'];
  /** @deprecated Provided only for legacy frontend. */
  databaseId: Scalars['Int']['output'];
  editPath: Scalars['String']['output'];
  /** @deprecated Note can now have multiple folders, use folders. */
  folderName?: Maybe<Scalars['String']['output']>;
  folders: FolderConnection;
  groups: Array<Group>;
  hasCollabHistory: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  inlineComments: InlineCommentConnection;
  isArchived: Scalars['Boolean']['output'];
  isLikedByCurrentUser: Scalars['Boolean']['output'];
  likers: UserConnection;
  path: Scalars['String']['output'];
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  relatedNotes: SearchResultConnection;
  reviewableDraft?: Maybe<ReviewableDraft>;
  selectableGroups: GroupConnection;
  sharedNote?: Maybe<SharedNote>;
  title: Scalars['String']['output'];
  trackbackNotes: NoteConnection;
  /** @deprecated This is beta and internal feature. */
  translationSource?: Maybe<Note>;
  updatedAt: Scalars['DateTime']['output'];
  url: Scalars['String']['output'];
};


/** The Note type */
export type NoteAttachmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The Note type */
export type NoteCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The Note type */
export type NoteContributorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributorOrder>;
};


/** The Note type */
export type NoteFoldersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The Note type */
export type NoteInlineCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The Note type */
export type NoteLikersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The Note type */
export type NoteRelatedNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The Note type */
export type NoteSelectableGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The Note type */
export type NoteTrackbackNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Browsing history of notes */
export type NoteBrowsingHistory = Node & {
  __typename?: 'NoteBrowsingHistory';
  id: Scalars['ID']['output'];
  note?: Maybe<Note>;
};

/** The connection type for NoteBrowsingHistory. */
export type NoteBrowsingHistoryConnection = {
  __typename?: 'NoteBrowsingHistoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteBrowsingHistoryEdge>>>;
  /** A list of nodes. */
  nodes: Array<NoteBrowsingHistory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type NoteBrowsingHistoryEdge = {
  __typename?: 'NoteBrowsingHistoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<NoteBrowsingHistory>;
};

/** The connection type for Note. */
export type NoteConnection = {
  __typename?: 'NoteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteEdge>>>;
  /** A list of nodes. */
  nodes: Array<Note>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type NoteEdge = {
  __typename?: 'NoteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Note>;
};

/** Note input struct, used to updateNote mutation */
export type NoteInput = {
  coediting: Scalars['Boolean']['input'];
  content: Scalars['String']['input'];
  folders?: InputMaybe<Array<FolderInput>>;
  groupIds: Array<Scalars['ID']['input']>;
  title: Scalars['String']['input'];
};

export type NoteOrder = {
  direction?: InputMaybe<OrderDirection>;
  field?: InputMaybe<NoteOrderField>;
};

/** Properties by which notes can be ordered. */
export enum NoteOrderField {
  ContentUpdatedAt = 'CONTENT_UPDATED_AT',
  PublishedAt = 'PUBLISHED_AT',
  Title = 'TITLE'
}

/** Template of note */
export type NoteTemplate = Node & {
  __typename?: 'NoteTemplate';
  coediting: Scalars['Boolean']['output'];
  content: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  evaluatedTitle: Scalars['String']['output'];
  folders: Array<NoteTemplateFolder>;
  groups: Array<Group>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for NoteTemplate. */
export type NoteTemplateConnection = {
  __typename?: 'NoteTemplateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteTemplateEdge>>>;
  /** A list of nodes. */
  nodes: Array<NoteTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type NoteTemplateEdge = {
  __typename?: 'NoteTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<NoteTemplate>;
};

/** Folder for note template. */
export type NoteTemplateFolder = Node & {
  __typename?: 'NoteTemplateFolder';
  createdAt: Scalars['DateTime']['output'];
  evaluatedFullName: Scalars['String']['output'];
  fullName: Scalars['String']['output'];
  group: Group;
  id: Scalars['ID']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

/** A selection of note for comment in text on note. */
export type NoteTextSelection = Node & {
  __typename?: 'NoteTextSelection';
  comment: InlineComment;
  content: Scalars['String']['output'];
  endColumnInMarkdown: Scalars['Int']['output'];
  endInText: Scalars['Int']['output'];
  endLineInMarkdown: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  startColumnInMarkdown: Scalars['Int']['output'];
  startInText: Scalars['Int']['output'];
  startLineInMarkdown: Scalars['Int']['output'];
};

/** The connection type for NoteTextSelection. */
export type NoteTextSelectionConnection = {
  __typename?: 'NoteTextSelectionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteTextSelectionEdge>>>;
  /** A list of nodes. */
  nodes: Array<NoteTextSelection>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type NoteTextSelectionEdge = {
  __typename?: 'NoteTextSelectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<NoteTextSelection>;
};

/** Note text selection input struct, used to updateNote mutation */
export type NoteTextSelectionInput = {
  deletedInEditor?: InputMaybe<Scalars['Boolean']['input']>;
  endColumnInMarkdown?: InputMaybe<Scalars['Int']['input']>;
  endInText?: InputMaybe<Scalars['Int']['input']>;
  endLineInMarkdown?: InputMaybe<Scalars['Int']['input']>;
  id: Scalars['ID']['input'];
  startColumnInMarkdown?: InputMaybe<Scalars['Int']['input']>;
  startInText?: InputMaybe<Scalars['Int']['input']>;
  startLineInMarkdown?: InputMaybe<Scalars['Int']['input']>;
};

/** Notifications you get in a Kibela team */
export type Notification = Node & {
  __typename?: 'Notification';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** @deprecated This field is for internal use only. */
  kind: Scalars['String']['output'];
  messageHtml: Scalars['String']['output'];
  sender: User;
  sourcePath: Scalars['String']['output'];
  state: NotificationState;
  updatedAt: Scalars['DateTime']['output'];
};

/** The connection type for Notification. */
export type NotificationConnection = {
  __typename?: 'NotificationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationEdge>>>;
  /** A list of nodes. */
  nodes: Array<Notification>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type NotificationEdge = {
  __typename?: 'NotificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Notification>;
};

/** The state of notifications */
export enum NotificationState {
  Read = 'READ',
  Unread = 'UNREAD'
}

/** OpenGraph data. */
export type OpenGraph = {
  __typename?: 'OpenGraph';
  description?: Maybe<Scalars['String']['output']>;
  image?: Maybe<OpenGraphImage>;
  title?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** OpenGraph Image */
export type OpenGraphImage = {
  __typename?: 'OpenGraphImage';
  alt?: Maybe<Scalars['String']['output']>;
  height?: Maybe<Scalars['Int']['output']>;
  secureUrl?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  width?: Maybe<Scalars['Int']['output']>;
};

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** Kind of the organization */
export enum OrganizationKind {
  Company = 'COMPANY',
  Other = 'OTHER',
  Personal = 'PERSONAL',
  Unknown = 'UNKNOWN'
}

/** A outgoing_webhook */
export type OutgoingWebhook = Node & {
  __typename?: 'OutgoingWebhook';
  disabledAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

/** The top-level query type to Kibela resources */
export type Query = {
  __typename?: 'Query';
  accessToken: AccessToken;
  accessTokens: AccessTokenConnection;
  /** The archived groups in the team including private ones */
  archivedGroups: GroupConnection;
  attachmentFromPath: Attachment;
  budget: Budget;
  /** @deprecated This is beta and internal feature. */
  coeditToken: Scalars['String']['output'];
  /** @deprecated This is an internal field. */
  collabModeData?: Maybe<CollabModeData>;
  comment: Comment;
  /** The current user of the session */
  currentUser: User;
  customEmojiFromCode: CustomEmoji;
  customEmojis: CustomEmojiConnection;
  /** @deprecated This is an internal feature. */
  customEmojisCacheKey: Scalars['String']['output'];
  defaultGroup?: Maybe<Group>;
  /** @deprecated This is beta and internal feature. */
  externalUrlData: ExternalUrlData;
  feedSections: FeedSectionSimpleConnection;
  folder: Folder;
  folderFromPath: Folder;
  /**
   * Returns all folders.
   * Note that the field does not distinguish groups.
   * If you need to fetch folders that is related a specific group, use GroupType.folders field.
   *
   */
  folders: FolderConnection;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String']['output'];
  group: Group;
  groupAnnouncement?: Maybe<GroupAnnouncement>;
  /** The active groups in the team. */
  groups: GroupConnection;
  /** @deprecated This is an internal and deprecated field. */
  importableUsers: Array<ImportableUser>;
  /** @deprecated This is beta and internal feature. */
  internalUrlData?: Maybe<InternalUrlData>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Fetches a list of objects given a list of IDs. */
  nodes: Array<Maybe<Node>>;
  note: Note;
  noteBrowsingHistories: NoteBrowsingHistoryConnection;
  noteFromPath: Note;
  noteTemplate: NoteTemplate;
  noteTemplates: NoteTemplateConnection;
  /** The connection of all the notes in the team. You *should* specify `orderBy` in production. */
  notes: NoteConnection;
  notifications: NotificationConnection;
  renderMarkdownToHtml: Scalars['String']['output'];
  reviewableDraft: ReviewableDraft;
  /** Search note/comment */
  search: SearchResultConnection;
  /** Search folder */
  searchFolder: SearchFolderResultConnection;
  serviceNotifications: ServiceNotificationConnection;
  sharedNote: SharedNote;
  /** All the shared notes in the team. */
  sharedNotes: SharedNoteConnection;
  similarNotes?: Maybe<SimilarNoteConnection>;
  summaryNoteHistory?: Maybe<SummaryNoteHistory>;
  synonymGroups: SynonymGroupConnection;
  /** All the access token logs in the team. This feature requires the administrative privileges */
  teamAccessTokenLogs: AccessTokenLogConnection;
  user: User;
  userFromAccount: User;
  /** The user list */
  userList: UserList;
  /** The user lists in the team. */
  userLists: UserListConnection;
  users: UserConnection;
  usersFromAccounts: UserConnection;
  /** @deprecated This is internal feature. */
  validateToMove: Scalars['Boolean']['output'];
};


/** The top-level query type to Kibela resources */
export type QueryAccessTokenArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  revoked?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryArchivedGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryAttachmentFromPathArgs = {
  path: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryCoeditTokenArgs = {
  noteId: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryCollabModeDataArgs = {
  noteId: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryCommentArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryCustomEmojiFromCodeArgs = {
  code: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryCustomEmojisArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryExternalUrlDataArgs = {
  url: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryFeedSectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
  groupId?: InputMaybe<Scalars['ID']['input']>;
  kind?: InputMaybe<FeedKind>;
};


/** The top-level query type to Kibela resources */
export type QueryFolderArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryFolderFromPathArgs = {
  path: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryFoldersArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  parentFolderId?: InputMaybe<Scalars['ID']['input']>;
  parentFolderIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


/** The top-level query type to Kibela resources */
export type QueryGroupArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryGroupAnnouncementArgs = {
  groupId: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryGroupsArgs = {
  ability?: InputMaybe<GroupAbility>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryImportableUsersArgs = {
  encryptedAccessToken: Scalars['String']['input'];
  page: Scalars['Int']['input'];
  serviceType: Scalars['String']['input'];
  teamName: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryInternalUrlDataArgs = {
  url: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryNoteArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryNoteBrowsingHistoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryNoteFromPathArgs = {
  path: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryNoteTemplateArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryNoteTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryNotesArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  folderId?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<NoteOrder>;
};


/** The top-level query type to Kibela resources */
export type QueryNotificationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<NotificationState>;
};


/** The top-level query type to Kibela resources */
export type QueryRenderMarkdownToHtmlArgs = {
  content: Scalars['String']['input'];
  isMain: Scalars['Boolean']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryReviewableDraftArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QuerySearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  coediting?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  folderIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  groupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  likerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  query: Scalars['String']['input'];
  resources?: InputMaybe<Array<SearchResourceKind>>;
  sortBy?: InputMaybe<SearchSortKind>;
  updated?: InputMaybe<SearchDate>;
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


/** The top-level query type to Kibela resources */
export type QuerySearchFolderArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryServiceNotificationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QuerySharedNoteArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QuerySharedNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QuerySimilarNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  title: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QuerySummaryNoteHistoryArgs = {
  slackChannelId: Scalars['String']['input'];
  slackThreadTs: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QuerySynonymGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryTeamAccessTokenLogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryUserArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryUserFromAccountArgs = {
  account: Scalars['String']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryUserListArgs = {
  id: Scalars['ID']['input'];
};


/** The top-level query type to Kibela resources */
export type QueryUserListsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  confirmed?: InputMaybe<Scalars['Boolean']['input']>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  groupId?: InputMaybe<Scalars['ID']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryUsersFromAccountsArgs = {
  accounts: Array<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** The top-level query type to Kibela resources */
export type QueryValidateToMoveArgs = {
  folderIds: Array<Scalars['ID']['input']>;
  groupId: Scalars['ID']['input'];
  parentId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated input type of RemoveFolderPin */
export type RemoveFolderPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Target folder. It is required when the note has 2 or more associated folders. */
  folder?: InputMaybe<FolderInput>;
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveFolderPin. */
export type RemoveFolderPinPayload = {
  __typename?: 'RemoveFolderPinPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  folder: Folder;
};

/** Autogenerated input type of RemoveGroupPin */
export type RemoveGroupPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveGroupPin. */
export type RemoveGroupPinPayload = {
  __typename?: 'RemoveGroupPinPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

/** Autogenerated input type of RemoveUsersFromUserList */
export type RemoveUsersFromUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  userIds: Array<Scalars['ID']['input']>;
  userListId: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveUsersFromUserList. */
export type RemoveUsersFromUserListPayload = {
  __typename?: 'RemoveUsersFromUserListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  userList: UserList;
};

/** Autogenerated input type of RequestAttachmentConversion */
export type RequestAttachmentConversionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RequestAttachmentConversion. */
export type RequestAttachmentConversionPayload = {
  __typename?: 'RequestAttachmentConversionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  conversionState: AttachmentFilePreviewConversionState;
};

/** Autogenerated input type of ResolveInlineComment */
export type ResolveInlineCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of ResolveInlineComment. */
export type ResolveInlineCommentPayload = {
  __typename?: 'ResolveInlineCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  comment: InlineComment;
};

/** Autogenerated input type of RestoreFolder */
export type RestoreFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RestoreFolder. */
export type RestoreFolderPayload = {
  __typename?: 'RestoreFolderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String']['output'];
};

/** Autogenerated input type of RestoreGroup */
export type RestoreGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
};

/** Autogenerated return type of RestoreGroup. */
export type RestoreGroupPayload = {
  __typename?: 'RestoreGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

/** Autogenerated input type of RestoreNote */
export type RestoreNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RestoreNote. */
export type RestoreNotePayload = {
  __typename?: 'RestoreNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** The Reviewable Draft type */
export type ReviewableDraft = {
  __typename?: 'ReviewableDraft';
  comments: ReviewableDraftCommentConnection;
  id: Scalars['ID']['output'];
  isEnabled: Scalars['Boolean']['output'];
  url: Scalars['String']['output'];
};


/** The Reviewable Draft type */
export type ReviewableDraftCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** A comment that belongs to a reviewable drarft */
export type ReviewableDraftComment = Node & {
  __typename?: 'ReviewableDraftComment';
  anchor: Scalars['String']['output'];
  author: User;
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  path: Scalars['String']['output'];
};

/** The connection type for ReviewableDraftComment. */
export type ReviewableDraftCommentConnection = {
  __typename?: 'ReviewableDraftCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewableDraftCommentEdge>>>;
  /** A list of nodes. */
  nodes: Array<ReviewableDraftComment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReviewableDraftCommentEdge = {
  __typename?: 'ReviewableDraftCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReviewableDraftComment>;
};

/** Autogenerated input type of RevokeAccessToken */
export type RevokeAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** AccessToken ID */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RevokeAccessToken. */
export type RevokeAccessTokenPayload = {
  __typename?: 'RevokeAccessTokenPayload';
  accessToken: AccessToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** A role of a user */
export enum Role {
  Admin = 'ADMIN',
  FullMember = 'FULL_MEMBER',
  Guest = 'GUEST',
  Owner = 'OWNER',
  ReadOnly = 'READ_ONLY'
}

export enum Saml2SsoMode {
  ModeDisabled = 'MODE_DISABLED',
  ModeMigration = 'MODE_MIGRATION',
  ModeSso = 'MODE_SSO'
}

export enum SearchDate {
  All = 'ALL',
  Within_1Month = 'WITHIN_1_MONTH',
  Within_1Week = 'WITHIN_1_WEEK',
  Within_1Year = 'WITHIN_1_YEAR',
  Within_3Days = 'WITHIN_3_DAYS',
  Within_6Months = 'WITHIN_6_MONTHS'
}

export type SearchFolderResult = {
  __typename?: 'SearchFolderResult';
  fixedPath: Scalars['String']['output'];
  group: Group;
  name: Scalars['String']['output'];
};

/** The connection type for SearchFolderResult. */
export type SearchFolderResultConnection = {
  __typename?: 'SearchFolderResultConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SearchFolderResultEdge>>>;
  /** A list of nodes. */
  nodes: Array<SearchFolderResult>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SearchFolderResultEdge = {
  __typename?: 'SearchFolderResultEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SearchFolderResult>;
};

/** Search target model type */
export enum SearchResourceKind {
  Attachment = 'ATTACHMENT',
  Comment = 'COMMENT',
  Note = 'NOTE'
}

/** A search result that refers to a document */
export type SearchResult = {
  __typename?: 'SearchResult';
  author: User;
  contentSummaryHtml: Scalars['String']['output'];
  contentUpdatedAt: Scalars['DateTime']['output'];
  contributors: UserConnection;
  /** The original searchable document */
  document: SearchableDocument;
  path: Scalars['String']['output'];
  title: Scalars['String']['output'];
  titleHtml: Scalars['String']['output'];
  url: Scalars['String']['output'];
};


/** A search result that refers to a document */
export type SearchResultContributorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributorOrder>;
};

/** The connection type for SearchResult. */
export type SearchResultConnection = {
  __typename?: 'SearchResultConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SearchResultEdge>>>;
  /** A list of nodes. */
  nodes: Array<SearchResult>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SearchResultEdge = {
  __typename?: 'SearchResultEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SearchResult>;
};

export enum SearchSortKind {
  Recent = 'RECENT',
  Relevant = 'RELEVANT'
}

export type SearchableDocument = Attachment | Comment | CommentReply | Note;

/** Get the latest news and useful information from Kibela */
export type ServiceNotification = Node & {
  __typename?: 'ServiceNotification';
  id: Scalars['ID']['output'];
  messageEn?: Maybe<Scalars['String']['output']>;
  messageJa: Scalars['String']['output'];
  notificationKind: ServiceNotificationKind;
  read: Scalars['Boolean']['output'];
  startAt: Scalars['DateTime']['output'];
  titleEn?: Maybe<Scalars['String']['output']>;
  titleJa: Scalars['String']['output'];
  urlEn?: Maybe<Scalars['String']['output']>;
  urlJa?: Maybe<Scalars['String']['output']>;
};

/** The connection type for ServiceNotification. */
export type ServiceNotificationConnection = {
  __typename?: 'ServiceNotificationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ServiceNotificationEdge>>>;
  /** A list of nodes. */
  nodes: Array<ServiceNotification>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ServiceNotificationEdge = {
  __typename?: 'ServiceNotificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ServiceNotification>;
};

/** The kind of ServiceNotifications */
export enum ServiceNotificationKind {
  Guide = 'GUIDE',
  Maintenance = 'MAINTENANCE',
  Marketing = 'MARKETING',
  NewFeature = 'NEW_FEATURE',
  Success = 'SUCCESS'
}

/** Autogenerated input type of SetFeedToHome */
export type SetFeedToHomeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  feed: FeedKindWithoutGroup;
};

/** Autogenerated return type of SetFeedToHome. */
export type SetFeedToHomePayload = {
  __typename?: 'SetFeedToHomePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  feed: FeedKindWithoutGroup;
};

/** Autogenerated input type of SetGroupToHome */
export type SetGroupToHomeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
};

/** Autogenerated return type of SetGroupToHome. */
export type SetGroupToHomePayload = {
  __typename?: 'SetGroupToHomePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

/** Autogenerated input type of ShareNoteWithOutsideOfTeam */
export type ShareNoteWithOutsideOfTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  endAt?: InputMaybe<Scalars['DateTime']['input']>;
  isEndAtEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  isPasswordEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  noteId: Scalars['ID']['input'];
  password?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of ShareNoteWithOutsideOfTeam. */
export type ShareNoteWithOutsideOfTeamPayload = {
  __typename?: 'ShareNoteWithOutsideOfTeamPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** The Shared Note type */
export type SharedNote = Node & {
  __typename?: 'SharedNote';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  note: Note;
  totalPageviews: Scalars['Int']['output'];
  url: Scalars['String']['output'];
};

/** The connection type for SharedNote. */
export type SharedNoteConnection = {
  __typename?: 'SharedNoteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SharedNoteEdge>>>;
  /** A list of nodes. */
  nodes: Array<SharedNote>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SharedNoteEdge = {
  __typename?: 'SharedNoteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SharedNote>;
};

/** Similar notes for given title and content */
export type SimilarNote = Node & {
  __typename?: 'SimilarNote';
  attachments: AttachmentConnection;
  author?: Maybe<User>;
  canBeArchived: Scalars['Boolean']['output'];
  canBeCommented: Scalars['Boolean']['output'];
  canBeDestroyed: Scalars['Boolean']['output'];
  canBeLiked: Scalars['Boolean']['output'];
  canBeUpdated: Scalars['Boolean']['output'];
  /** @deprecated This is beta and internal feature. */
  coeditRoom?: Maybe<CoeditRoom>;
  coediting: Scalars['Boolean']['output'];
  comments: CommentConnection;
  commentsCount: Scalars['Int']['output'];
  content: Scalars['String']['output'];
  contentHtml: Scalars['String']['output'];
  contentSummaryHtml: Scalars['String']['output'];
  contentTocHtml: Scalars['String']['output'];
  contentUpdatedAt: Scalars['DateTime']['output'];
  contributors: UserConnection;
  createdAt: Scalars['DateTime']['output'];
  /** @deprecated Provided only for legacy frontend. */
  databaseId: Scalars['Int']['output'];
  editPath: Scalars['String']['output'];
  /** @deprecated Note can now have multiple folders, use folders. */
  folderName?: Maybe<Scalars['String']['output']>;
  folders: FolderConnection;
  groups: Array<Group>;
  hasCollabHistory: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  inlineComments: InlineCommentConnection;
  isArchived: Scalars['Boolean']['output'];
  isLikedByCurrentUser: Scalars['Boolean']['output'];
  likers: UserConnection;
  path: Scalars['String']['output'];
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  relatedNotes: SearchResultConnection;
  reviewableDraft?: Maybe<ReviewableDraft>;
  selectableGroups: GroupConnection;
  sharedNote?: Maybe<SharedNote>;
  title: Scalars['String']['output'];
  trackbackNotes: NoteConnection;
  /** @deprecated This is beta and internal feature. */
  translationSource?: Maybe<Note>;
  updatedAt: Scalars['DateTime']['output'];
  url: Scalars['String']['output'];
};


/** Similar notes for given title and content */
export type SimilarNoteAttachmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Similar notes for given title and content */
export type SimilarNoteCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Similar notes for given title and content */
export type SimilarNoteContributorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ContributorOrder>;
};


/** Similar notes for given title and content */
export type SimilarNoteFoldersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Similar notes for given title and content */
export type SimilarNoteInlineCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Similar notes for given title and content */
export type SimilarNoteLikersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Similar notes for given title and content */
export type SimilarNoteRelatedNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Similar notes for given title and content */
export type SimilarNoteSelectableGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Similar notes for given title and content */
export type SimilarNoteTrackbackNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for SimilarNote. */
export type SimilarNoteConnection = {
  __typename?: 'SimilarNoteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SimilarNoteEdge>>>;
  /** A list of nodes. */
  nodes: Array<SimilarNote>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SimilarNoteEdge = {
  __typename?: 'SimilarNoteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SimilarNote>;
};

/** Autogenerated input type of SortGroupPins */
export type SortGroupPinsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  noteIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of SortGroupPins. */
export type SortGroupPinsPayload = {
  __typename?: 'SortGroupPinsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

export type Subscription = {
  __typename?: 'Subscription';
  aiReviewUpdated?: Maybe<AiReviewUpdatedPayload>;
  healthCheck?: Maybe<HealthCheckedPayload>;
};


export type SubscriptionAiReviewUpdatedArgs = {
  id: Scalars['String']['input'];
};

export type SummaryNoteHistory = Node & {
  __typename?: 'SummaryNoteHistory';
  id: Scalars['ID']['output'];
  note: Note;
};

/** Autogenerated input type of SyncUserLastUsedEditor */
export type SyncUserLastUsedEditorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  kind: UserLastUsedEditorKind;
};

/** Autogenerated return type of SyncUserLastUsedEditor. */
export type SyncUserLastUsedEditorPayload = {
  __typename?: 'SyncUserLastUsedEditorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

export type SynonymGroup = {
  __typename?: 'SynonymGroup';
  id: Scalars['ID']['output'];
  lastAuthor: User;
  updatedAt: Scalars['DateTime']['output'];
  words: Array<Scalars['String']['output']>;
};

/** The connection type for SynonymGroup. */
export type SynonymGroupConnection = {
  __typename?: 'SynonymGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SynonymGroupEdge>>>;
  /** A list of nodes. */
  nodes: Array<SynonymGroup>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SynonymGroupEdge = {
  __typename?: 'SynonymGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SynonymGroup>;
};

/** Autogenerated input type of TransferGroupNotes */
export type TransferGroupNotesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fromGroupId: Scalars['ID']['input'];
  toGroupId: Scalars['ID']['input'];
};

/** Autogenerated return type of TransferGroupNotes. */
export type TransferGroupNotesPayload = {
  __typename?: 'TransferGroupNotesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  from: Group;
  to: Group;
};

/** Autogenerated input type of Unlike */
export type UnlikeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  likableId: Scalars['ID']['input'];
};

/** Autogenerated return type of Unlike. */
export type UnlikePayload = {
  __typename?: 'UnlikePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  likers: UserConnection;
};


/** Autogenerated return type of Unlike. */
export type UnlikePayloadLikersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UnresolveInlineComment */
export type UnresolveInlineCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UnresolveInlineComment. */
export type UnresolveInlineCommentPayload = {
  __typename?: 'UnresolveInlineCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  comment: InlineComment;
};

/** Autogenerated input type of UnshareNoteWithOutsideOfTeam */
export type UnshareNoteWithOutsideOfTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnshareNoteWithOutsideOfTeam. */
export type UnshareNoteWithOutsideOfTeamPayload = {
  __typename?: 'UnshareNoteWithOutsideOfTeamPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** Autogenerated input type of UnwatchNote */
export type UnwatchNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of UnwatchNote. */
export type UnwatchNotePayload = {
  __typename?: 'UnwatchNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateAccessToken */
export type UpdateAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  scopes: Array<AccessTokenScope>;
  title: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateAccessToken. */
export type UpdateAccessTokenPayload = {
  __typename?: 'UpdateAccessTokenPayload';
  accessToken: AccessToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateComment */
export type UpdateCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  content: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  touch?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of UpdateComment. */
export type UpdateCommentPayload = {
  __typename?: 'UpdateCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  comment: Comment;
};

/** Autogenerated input type of UpdateCommentReply */
export type UpdateCommentReplyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  content: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  touch?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of UpdateCommentReply. */
export type UpdateCommentReplyPayload = {
  __typename?: 'UpdateCommentReplyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  reply: CommentReply;
};

/** Autogenerated input type of UpdateDashboardContent */
export type UpdateDashboardContentInput = {
  baseContent: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** A group ID for the dashboard */
  groupId: Scalars['ID']['input'];
  newContent: Scalars['String']['input'];
  seqNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdateDashboardContent. */
export type UpdateDashboardContentPayload = {
  __typename?: 'UpdateDashboardContentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dashboard: Dashboard;
};

/** Autogenerated input type of UpdateDashboard */
export type UpdateDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  content: Scalars['String']['input'];
  groupId: Scalars['ID']['input'];
  seqNumber?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateDashboard. */
export type UpdateDashboardPayload = {
  __typename?: 'UpdateDashboardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dashboard: Dashboard;
};

/** Autogenerated input type of UpdateFolderName */
export type UpdateFolderNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateFolderName. */
export type UpdateFolderNamePayload = {
  __typename?: 'UpdateFolderNamePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String']['output'];
};

/** Autogenerated input type of UpdateFolderParent */
export type UpdateFolderParentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** New parent folder path (ex. aaa/bbb) */
  folderFullName?: InputMaybe<Scalars['String']['input']>;
  /** Target folder id */
  folderId: Scalars['ID']['input'];
  /** Group id of the destination */
  groupId?: InputMaybe<Scalars['ID']['input']>;
};

/** Autogenerated return type of UpdateFolderParent. */
export type UpdateFolderParentPayload = {
  __typename?: 'UpdateFolderParentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String']['output'];
};

/** Autogenerated input type of UpdateGroupAnnouncement */
export type UpdateGroupAnnouncementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  referentFolders: Array<GroupAnnouncementFolderInput>;
};

/** Autogenerated return type of UpdateGroupAnnouncement. */
export type UpdateGroupAnnouncementPayload = {
  __typename?: 'UpdateGroupAnnouncementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  groupAnnouncement: GroupAnnouncement;
};

/** Autogenerated input type of UpdateGroup */
export type UpdateGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  coverImageKey?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<GroupType>;
};

/** Autogenerated input type of UpdateGroupMember */
export type UpdateGroupMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupId: Scalars['ID']['input'];
  role: GroupMemberRole;
  userId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateGroupMember. */
export type UpdateGroupMemberPayload = {
  __typename?: 'UpdateGroupMemberPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  groupMember: GroupMember;
};

/** Autogenerated return type of UpdateGroup. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  group: Group;
};

/** Autogenerated input type of UpdateNoteContent */
export type UpdateNoteContentInput = {
  baseContent: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  newContent: Scalars['String']['input'];
  /** If false, content_updated_at is not touched. */
  touch?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of UpdateNoteContent. */
export type UpdateNoteContentPayload = {
  __typename?: 'UpdateNoteContentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** Autogenerated input type of UpdateNoteGroups */
export type UpdateNoteGroupsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupIds: Array<Scalars['ID']['input']>;
  noteId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateNoteGroups. */
export type UpdateNoteGroupsPayload = {
  __typename?: 'UpdateNoteGroupsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** Autogenerated input type of UpdateNote */
export type UpdateNoteInput = {
  baseNote: NoteInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  contributors?: InputMaybe<Array<ContributorInput>>;
  draft: Scalars['Boolean']['input'];
  id: Scalars['ID']['input'];
  newNote: NoteInput;
  /** It will be truncated to 100 characters if exceeded. */
  noteEditMemo?: InputMaybe<Scalars['String']['input']>;
  noteTextSelections?: InputMaybe<Array<NoteTextSelectionInput>>;
};

/** Autogenerated return type of UpdateNote. */
export type UpdateNotePayload = {
  __typename?: 'UpdateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** Autogenerated input type of UpdateNoteTemplate */
export type UpdateNoteTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  coediting: Scalars['Boolean']['input'];
  content: Scalars['String']['input'];
  folders?: InputMaybe<Array<FolderInput>>;
  groupIds: Array<Scalars['ID']['input']>;
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  title: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateNoteTemplate. */
export type UpdateNoteTemplatePayload = {
  __typename?: 'UpdateNoteTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  noteTemplate: NoteTemplate;
};

/** Autogenerated input type of UpdateNoteTitle */
export type UpdateNoteTitleInput = {
  baseTitle: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  newTitle: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateNoteTitle. */
export type UpdateNoteTitlePayload = {
  __typename?: 'UpdateNoteTitlePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** Autogenerated input type of UpdateSaml2SsoSetting */
export type UpdateSaml2SsoSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  mode: Saml2SsoMode;
  readOnlyUserPasswordAuthnEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Autogenerated return type of UpdateSaml2SsoSetting. */
export type UpdateSaml2SsoSettingPayload = {
  __typename?: 'UpdateSaml2SsoSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateSummaryNote */
export type UpdateSummaryNoteInput = {
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   *
   */
  authorEmail: Scalars['String']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** This text is saved at the end of the body text. */
  endContent?: InputMaybe<Scalars['String']['input']>;
  newContent: Scalars['String']['input'];
  /** This text is saved at the beginning of the body text. */
  preContent?: InputMaybe<Scalars['String']['input']>;
  slackChannelId: Scalars['String']['input'];
  slackThreadTs: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateSummaryNote. */
export type UpdateSummaryNotePayload = {
  __typename?: 'UpdateSummaryNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  note: Note;
};

/** Autogenerated input type of UpdateSynonymGroup */
export type UpdateSynonymGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  words: Array<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateSynonymGroup. */
export type UpdateSynonymGroupPayload = {
  __typename?: 'UpdateSynonymGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateTeamSetting */
export type UpdateTeamSettingInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  departmentName?: InputMaybe<Scalars['String']['input']>;
  inChargeUserId?: InputMaybe<Scalars['ID']['input']>;
  mainPurposes?: InputMaybe<Array<MainPurpose>>;
  organizationKind?: InputMaybe<OrganizationKind>;
  organizationName?: InputMaybe<Scalars['String']['input']>;
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  postalCode?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
  streetAddress?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateTeamSetting. */
export type UpdateTeamSettingPayload = {
  __typename?: 'UpdateTeamSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateUserList */
export type UpdateUserListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateUserList. */
export type UpdateUserListPayload = {
  __typename?: 'UpdateUserListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  userList: UserList;
};

/** Autogenerated input type of UpdateUserNotificationSetting */
export type UpdateUserNotificationSettingInput = {
  checked: Scalars['Boolean']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  kind: UserNotificationSettingKind;
};

/** Autogenerated return type of UpdateUserNotificationSetting. */
export type UpdateUserNotificationSettingPayload = {
  __typename?: 'UpdateUserNotificationSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateUsersGroups */
export type UpdateUsersGroupsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  groupIds: Array<Scalars['ID']['input']>;
  userIds: Array<Scalars['ID']['input']>;
};

/** Autogenerated return type of UpdateUsersGroups. */
export type UpdateUsersGroupsPayload = {
  __typename?: 'UpdateUsersGroupsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  groups: GroupConnection;
  users: UserConnection;
};


/** Autogenerated return type of UpdateUsersGroups. */
export type UpdateUsersGroupsPayloadGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** Autogenerated return type of UpdateUsersGroups. */
export type UpdateUsersGroupsPayloadUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UploadAttachment */
export type UploadAttachmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  data: Scalars['Blob']['input'];
  /** It indicates how and where the attachment is used. */
  kind: AttachmentKind;
  /** The name of attachment, typically a filename. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of UploadAttachment. */
export type UploadAttachmentPayload = {
  __typename?: 'UploadAttachmentPayload';
  attachment: Attachment;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UploadAttachmentWithDataUrl */
export type UploadAttachmentWithDataUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The data which encoded in Data URL scheme defined in RFC 2397 */
  dataUrl: Scalars['String']['input'];
  /** It indicates how and where the attachment is used. */
  kind: AttachmentKind;
  /** The name of attachment, typically a filename. */
  name: Scalars['String']['input'];
};

/** Autogenerated return type of UploadAttachmentWithDataUrl. */
export type UploadAttachmentWithDataUrlPayload = {
  __typename?: 'UploadAttachmentWithDataUrlPayload';
  attachment: Attachment;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** A user, which is an individual account of a team */
export type User = Node & {
  __typename?: 'User';
  account: Scalars['String']['output'];
  avatarImage: UserAvatarImage;
  biography?: Maybe<Scalars['String']['output']>;
  coverImage?: Maybe<UserCoverImage>;
  /** `email` requires administrative privileges because it is a kind of personal data. */
  email: Scalars['String']['output'];
  groups: GroupConnection;
  id: Scalars['ID']['output'];
  isOptOutCollabModeStartDialog: Scalars['Boolean']['output'];
  /** User's notes sorted by createdAt desc */
  latestNotes: NoteConnection;
  locale: Scalars['String']['output'];
  path?: Maybe<Scalars['String']['output']>;
  /** User's popular notes */
  popularNotes: NoteConnection;
  /** User's draft notes */
  privateNotes: NoteConnection;
  realName: Scalars['String']['output'];
  /** User's notes sorted by contentUpdatedAt desc */
  recentNotes: NoteConnection;
  role: Role;
  shortBio?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};


/** A user, which is an individual account of a team */
export type UserAvatarImageArgs = {
  density?: InputMaybe<Scalars['Int']['input']>;
  size?: InputMaybe<UserAvatarImageSize>;
};


/** A user, which is an individual account of a team */
export type UserCoverImageArgs = {
  density?: InputMaybe<Scalars['Int']['input']>;
  size?: InputMaybe<UserCoverImageSize>;
};


/** A user, which is an individual account of a team */
export type UserGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user, which is an individual account of a team */
export type UserLatestNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user, which is an individual account of a team */
export type UserPopularNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user, which is an individual account of a team */
export type UserPrivateNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A user, which is an individual account of a team */
export type UserRecentNotesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** An avatar image of users */
export type UserAvatarImage = {
  __typename?: 'UserAvatarImage';
  density: Scalars['Int']['output'];
  height: Scalars['Int']['output'];
  url: Scalars['String']['output'];
  width: Scalars['Int']['output'];
};

/** The size class of user avatar images */
export enum UserAvatarImageSize {
  Large = 'LARGE',
  Medium = 'MEDIUM',
  Small = 'SMALL'
}

/** The connection type for User. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** A cover image of users */
export type UserCoverImage = {
  __typename?: 'UserCoverImage';
  density: Scalars['Int']['output'];
  height: Scalars['Int']['output'];
  key: Scalars['String']['output'];
  size: UserCoverImageSize;
  url: Scalars['String']['output'];
  width: Scalars['Int']['output'];
};

/** The size class of user cover images */
export enum UserCoverImageSize {
  Medium = 'MEDIUM',
  Original = 'ORIGINAL',
  Small = 'SMALL'
}

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** The kind of user last used_editor */
export enum UserLastUsedEditorKind {
  MarkdownEditor = 'MARKDOWN_EDITOR',
  RichTextEditor = 'RICH_TEXT_EDITOR'
}

export type UserList = Node & {
  __typename?: 'UserList';
  createdAt: Scalars['DateTime']['output'];
  groups: GroupConnection;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  users: UserConnection;
};


export type UserListGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type UserListUsersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** The connection type for UserList. */
export type UserListConnection = {
  __typename?: 'UserListConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserListEdge>>>;
  /** A list of nodes. */
  nodes: Array<UserList>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserListEdge = {
  __typename?: 'UserListEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserList>;
};

export type UserListGroupMember = Node & {
  __typename?: 'UserListGroupMember';
  id: Scalars['ID']['output'];
  role?: Maybe<GroupMemberRole>;
  userList: UserList;
};

/** The connection type for UserListGroupMember. */
export type UserListGroupMemberConnection = {
  __typename?: 'UserListGroupMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserListGroupMemberEdge>>>;
  /** A list of nodes. */
  nodes: Array<UserListGroupMember>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserListGroupMemberEdge = {
  __typename?: 'UserListGroupMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserListGroupMember>;
};

/** The kind of user notification settings */
export enum UserNotificationSettingKind {
  NewsletterMail = 'NEWSLETTER_MAIL',
  ServiceNotificationWeb = 'SERVICE_NOTIFICATION_WEB'
}

/** Autogenerated input type of WatchNote */
export type WatchNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  noteId: Scalars['ID']['input'];
  /** note_update or comment. */
  watchedAction: WatchState;
};

/** Autogenerated return type of WatchNote. */
export type WatchNotePayload = {
  __typename?: 'WatchNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
};

/** State of watching note */
export enum WatchState {
  WatchComment = 'WATCH_COMMENT',
  WatchNoteUpdate = 'WATCH_NOTE_UPDATE'
}

export type AttachNoteToFolderMutationVariables = Exact<{
  input: AttachNoteToFolderInput;
}>;


export type AttachNoteToFolderMutation = { __typename?: 'Mutation', attachNoteToFolder: { __typename?: 'AttachNoteToFolderPayload', note: { __typename?: 'Note', id: string } } };

export type CreateCommentMutationVariables = Exact<{
  input: CreateCommentInput;
}>;


export type CreateCommentMutation = { __typename?: 'Mutation', createComment: { __typename?: 'CreateCommentPayload', comment: { __typename?: 'Comment', id: string } } };

export type CreateCommentReplyMutationVariables = Exact<{
  input: CreateCommentReplyInput;
}>;


export type CreateCommentReplyMutation = { __typename?: 'Mutation', createCommentReply: { __typename?: 'CreateCommentReplyPayload', reply: { __typename?: 'CommentReply', id: string } } };

export type CreateFolderMutationVariables = Exact<{
  input: CreateFolderInput;
}>;


export type CreateFolderMutation = { __typename?: 'Mutation', createFolder: { __typename?: 'CreateFolderPayload', folder: { __typename?: 'Folder', id: string } } };

export type CreateNoteMutationVariables = Exact<{
  input: CreateNoteInput;
}>;


export type CreateNoteMutation = { __typename?: 'Mutation', createNote: { __typename?: 'CreateNotePayload', note: { __typename?: 'Note', id: string, url: string } } };

export type GetCurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', account: string, realName: string, locale: string } };

export type GetFeedSectionsQueryVariables = Exact<{
  kind: FeedKind;
  groupId: Scalars['ID']['input'];
  first: Scalars['Int']['input'];
}>;


export type GetFeedSectionsQuery = { __typename?: 'Query', feedSections: { __typename?: 'FeedSectionSimpleConnection', edges: Array<{ __typename?: 'FeedSectionSimpleEdge', node: { __typename?: 'FeedFolderParcel', date: any, folder: { __typename?: 'Folder', id: string, name: string }, notes: { __typename?: 'NoteConnection', edges?: Array<{ __typename?: 'NoteEdge', node?: { __typename?: 'Note', id: string, title: string, contentSummaryHtml: string } | null } | null> | null } } | { __typename?: 'FeedNote', date: any, note: { __typename?: 'Note', id: string, title: string, contentSummaryHtml: string } } | { __typename?: 'FeedUserParcel', date: any, user: { __typename?: 'User', account: string, realName: string }, notes: { __typename?: 'NoteConnection', edges?: Array<{ __typename?: 'NoteEdge', node?: { __typename?: 'Note', id: string, title: string, contentSummaryHtml: string } | null } | null> | null } } }> } };

export type GetFolderQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first: Scalars['Int']['input'];
}>;


export type GetFolderQuery = { __typename?: 'Query', folder: { __typename?: 'Folder', name: string, fullName: string, fixedPath: string, createdAt: any, updatedAt: any, group: { __typename?: 'Group', id: string, name: string }, folders: { __typename?: 'FolderConnection', edges?: Array<{ __typename?: 'FolderEdge', node?: { __typename?: 'Folder', id: string, name: string } | null } | null> | null }, notes: { __typename?: 'NoteConnection', edges?: Array<{ __typename?: 'NoteEdge', node?: { __typename?: 'Note', id: string, title: string } | null } | null> | null } } };

export type GetFolderFromPathQueryVariables = Exact<{
  path: Scalars['String']['input'];
  first: Scalars['Int']['input'];
}>;


export type GetFolderFromPathQuery = { __typename?: 'Query', folderFromPath: { __typename?: 'Folder', name: string, fullName: string, fixedPath: string, createdAt: any, updatedAt: any, group: { __typename?: 'Group', id: string, name: string }, folders: { __typename?: 'FolderConnection', edges?: Array<{ __typename?: 'FolderEdge', node?: { __typename?: 'Folder', id: string, name: string } | null } | null> | null }, notes: { __typename?: 'NoteConnection', edges?: Array<{ __typename?: 'NoteEdge', node?: { __typename?: 'Note', id: string, title: string } | null } | null> | null } } };

export type GetFoldersQueryVariables = Exact<{
  first: Scalars['Int']['input'];
}>;


export type GetFoldersQuery = { __typename?: 'Query', folders: { __typename?: 'FolderConnection', edges?: Array<{ __typename?: 'FolderEdge', node?: { __typename?: 'Folder', id: string, name: string } | null } | null> | null } };

export type GetGroupsQueryVariables = Exact<{
  first: Scalars['Int']['input'];
}>;


export type GetGroupsQuery = { __typename?: 'Query', groups: { __typename?: 'GroupConnection', edges?: Array<{ __typename?: 'GroupEdge', node?: { __typename?: 'Group', id: string, name: string, isDefault: boolean, isArchived: boolean } | null } | null> | null } };

export type GetNoteQueryVariables = Exact<{
  id: Scalars['ID']['input'];
  first: Scalars['Int']['input'];
}>;


export type GetNoteQuery = { __typename?: 'Query', note: { __typename?: 'Note', title: string, content: string, url: string, author?: { __typename?: 'User', account: string, realName: string } | null, folders: { __typename?: 'FolderConnection', edges?: Array<{ __typename?: 'FolderEdge', node?: { __typename?: 'Folder', id: string, name: string, fullName: string, fixedPath: string, group: { __typename?: 'Group', id: string, name: string } } | null } | null> | null }, comments: { __typename?: 'CommentConnection', edges?: Array<{ __typename?: 'CommentEdge', node?: { __typename?: 'Comment', id: string, anchor: string, content: string, author: { __typename?: 'User', account: string, realName: string }, replies: { __typename?: 'CommentReplyConnection', edges?: Array<{ __typename?: 'CommentReplyEdge', node?: { __typename?: 'CommentReply', id: string, anchor: string, content: string, author: { __typename?: 'User', account: string, realName: string } } | null } | null> | null } } | null } | null> | null }, inlineComments: { __typename?: 'InlineCommentConnection', edges?: Array<{ __typename?: 'InlineCommentEdge', node?: { __typename?: 'InlineComment', id: string, anchor: string, content: string, author: { __typename?: 'User', account: string, realName: string }, replies: { __typename?: 'CommentReplyConnection', edges?: Array<{ __typename?: 'CommentReplyEdge', node?: { __typename?: 'CommentReply', id: string, anchor: string, content: string, author: { __typename?: 'User', account: string, realName: string } } | null } | null> | null } } | null } | null> | null } } };

export type GetNoteFromPathQueryVariables = Exact<{
  path: Scalars['String']['input'];
  first: Scalars['Int']['input'];
}>;


export type GetNoteFromPathQuery = { __typename?: 'Query', noteFromPath: { __typename?: 'Note', id: string, title: string, content: string, url: string, author?: { __typename?: 'User', account: string, realName: string } | null, folders: { __typename?: 'FolderConnection', edges?: Array<{ __typename?: 'FolderEdge', node?: { __typename?: 'Folder', id: string, name: string, fullName: string, fixedPath: string, group: { __typename?: 'Group', id: string, name: string } } | null } | null> | null }, comments: { __typename?: 'CommentConnection', edges?: Array<{ __typename?: 'CommentEdge', node?: { __typename?: 'Comment', id: string, anchor: string, content: string, author: { __typename?: 'User', account: string, realName: string }, replies: { __typename?: 'CommentReplyConnection', edges?: Array<{ __typename?: 'CommentReplyEdge', node?: { __typename?: 'CommentReply', id: string, anchor: string, content: string, author: { __typename?: 'User', account: string, realName: string } } | null } | null> | null } } | null } | null> | null }, inlineComments: { __typename?: 'InlineCommentConnection', edges?: Array<{ __typename?: 'InlineCommentEdge', node?: { __typename?: 'InlineComment', id: string, anchor: string, content: string, author: { __typename?: 'User', account: string, realName: string }, replies: { __typename?: 'CommentReplyConnection', edges?: Array<{ __typename?: 'CommentReplyEdge', node?: { __typename?: 'CommentReply', id: string, anchor: string, content: string, author: { __typename?: 'User', account: string, realName: string } } | null } | null> | null } } | null } | null> | null } } };

export type GetNotesQueryVariables = Exact<{
  folderId: Scalars['ID']['input'];
  first: Scalars['Int']['input'];
  last?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetNotesQuery = { __typename?: 'Query', notes: { __typename?: 'NoteConnection', edges?: Array<{ __typename?: 'NoteEdge', node?: { __typename?: 'Note', id: string, title: string, url: string } | null } | null> | null } };

export type MoveNoteToAnotherFolderMutationVariables = Exact<{
  input: MoveNoteToAnotherFolderInput;
}>;


export type MoveNoteToAnotherFolderMutation = { __typename?: 'Mutation', moveNoteToAnotherFolder: { __typename?: 'MoveNoteToAnotherFolderPayload', note: { __typename?: 'Note', id: string } } };

export type SearchFolderQueryVariables = Exact<{
  query: Scalars['String']['input'];
  first: Scalars['Int']['input'];
}>;


export type SearchFolderQuery = { __typename?: 'Query', searchFolder: { __typename?: 'SearchFolderResultConnection', edges?: Array<{ __typename?: 'SearchFolderResultEdge', node?: { __typename?: 'SearchFolderResult', name: string, fixedPath: string, group: { __typename?: 'Group', name: string, isPrivate: boolean } } | null } | null> | null } };

export type SearchNoteQueryVariables = Exact<{
  query: Scalars['String']['input'];
  resources?: InputMaybe<Array<SearchResourceKind> | SearchResourceKind>;
  coediting?: InputMaybe<Scalars['Boolean']['input']>;
  updated?: InputMaybe<SearchDate>;
  groupIds?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>;
  folderIds?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>;
  likerIds?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>;
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  sortBy?: InputMaybe<SearchSortKind>;
  first: Scalars['Int']['input'];
}>;


export type SearchNoteQuery = { __typename?: 'Query', search: { __typename?: 'SearchResultConnection', edges?: Array<{ __typename?: 'SearchResultEdge', node?: { __typename?: 'SearchResult', title: string, url: string, contentSummaryHtml: string, path: string, document: { __typename?: 'Attachment', id: string } | { __typename?: 'Comment', id: string } | { __typename?: 'CommentReply', id: string } | { __typename?: 'Note', id: string }, author: { __typename?: 'User', account: string, realName: string } } | null } | null> | null } };

export type UpdateNoteContentMutationVariables = Exact<{
  input: UpdateNoteContentInput;
}>;


export type UpdateNoteContentMutation = { __typename?: 'Mutation', updateNoteContent: { __typename?: 'UpdateNoteContentPayload', note: { __typename?: 'Note', id: string } } };


export const AttachNoteToFolderDocument = gql`
    mutation AttachNoteToFolder($input: AttachNoteToFolderInput!) {
  attachNoteToFolder(input: $input) {
    note {
      id
    }
  }
}
    `;
export const CreateCommentDocument = gql`
    mutation CreateComment($input: CreateCommentInput!) {
  createComment(input: $input) {
    comment {
      id
    }
  }
}
    `;
export const CreateCommentReplyDocument = gql`
    mutation CreateCommentReply($input: CreateCommentReplyInput!) {
  createCommentReply(input: $input) {
    reply {
      id
    }
  }
}
    `;
export const CreateFolderDocument = gql`
    mutation CreateFolder($input: CreateFolderInput!) {
  createFolder(input: $input) {
    folder {
      id
    }
  }
}
    `;
export const CreateNoteDocument = gql`
    mutation CreateNote($input: CreateNoteInput!) {
  createNote(input: $input) {
    note {
      id
      url
    }
  }
}
    `;
export const GetCurrentUserDocument = gql`
    query GetCurrentUser {
  currentUser {
    account
    realName
    locale
  }
}
    `;
export const GetFeedSectionsDocument = gql`
    query GetFeedSections($kind: FeedKind!, $groupId: ID!, $first: Int!) {
  feedSections(kind: $kind, groupId: $groupId, first: $first) {
    edges {
      node {
        ... on FeedNote {
          date
          note {
            id
            title
            contentSummaryHtml
          }
        }
        ... on FeedFolderParcel {
          date
          folder {
            id
            name
          }
          notes(first: $first) {
            edges {
              node {
                id
                title
                contentSummaryHtml
              }
            }
          }
        }
        ... on FeedUserParcel {
          date
          user {
            account
            realName
          }
          notes(first: $first) {
            edges {
              node {
                id
                title
                contentSummaryHtml
              }
            }
          }
        }
      }
    }
  }
}
    `;
export const GetFolderDocument = gql`
    query GetFolder($id: ID!, $first: Int!) {
  folder(id: $id) {
    name
    fullName
    fixedPath
    createdAt
    updatedAt
    group {
      id
      name
    }
    folders(first: $first) {
      edges {
        node {
          id
          name
        }
      }
    }
    notes(first: $first) {
      edges {
        node {
          id
          title
        }
      }
    }
  }
}
    `;
export const GetFolderFromPathDocument = gql`
    query GetFolderFromPath($path: String!, $first: Int!) {
  folderFromPath(path: $path) {
    name
    fullName
    fixedPath
    createdAt
    updatedAt
    group {
      id
      name
    }
    folders(first: $first) {
      edges {
        node {
          id
          name
        }
      }
    }
    notes(first: $first) {
      edges {
        node {
          id
          title
        }
      }
    }
  }
}
    `;
export const GetFoldersDocument = gql`
    query GetFolders($first: Int!) {
  folders(first: $first) {
    edges {
      node {
        id
        name
      }
    }
  }
}
    `;
export const GetGroupsDocument = gql`
    query GetGroups($first: Int!) {
  groups(first: $first) {
    edges {
      node {
        id
        name
        isDefault
        isArchived
      }
    }
  }
}
    `;
export const GetNoteDocument = gql`
    query GetNote($id: ID!, $first: Int!) {
  note(id: $id) {
    title
    content
    url
    author {
      account
      realName
    }
    folders(first: $first) {
      edges {
        node {
          id
          name
          fullName
          fixedPath
          group {
            id
            name
          }
        }
      }
    }
    comments(first: $first) {
      edges {
        node {
          id
          anchor
          content
          author {
            account
            realName
          }
          replies(first: $first) {
            edges {
              node {
                id
                anchor
                content
                author {
                  account
                  realName
                }
              }
            }
          }
        }
      }
    }
    inlineComments(first: $first) {
      edges {
        node {
          id
          anchor
          content
          author {
            account
            realName
          }
          replies(first: $first) {
            edges {
              node {
                id
                anchor
                content
                author {
                  account
                  realName
                }
              }
            }
          }
        }
      }
    }
  }
}
    `;
export const GetNoteFromPathDocument = gql`
    query GetNoteFromPath($path: String!, $first: Int!) {
  noteFromPath(path: $path) {
    id
    title
    content
    url
    author {
      account
      realName
    }
    folders(first: $first) {
      edges {
        node {
          id
          name
          fullName
          fixedPath
          group {
            id
            name
          }
        }
      }
    }
    comments(first: $first) {
      edges {
        node {
          id
          anchor
          content
          author {
            account
            realName
          }
          replies(first: $first) {
            edges {
              node {
                id
                anchor
                content
                author {
                  account
                  realName
                }
              }
            }
          }
        }
      }
    }
    inlineComments(first: $first) {
      edges {
        node {
          id
          anchor
          content
          author {
            account
            realName
          }
          replies(first: $first) {
            edges {
              node {
                id
                anchor
                content
                author {
                  account
                  realName
                }
              }
            }
          }
        }
      }
    }
  }
}
    `;
export const GetNotesDocument = gql`
    query GetNotes($folderId: ID!, $first: Int!, $last: Int) {
  notes(folderId: $folderId, first: $first, last: $last) {
    edges {
      node {
        id
        title
        url
      }
    }
  }
}
    `;
export const MoveNoteToAnotherFolderDocument = gql`
    mutation MoveNoteToAnotherFolder($input: MoveNoteToAnotherFolderInput!) {
  moveNoteToAnotherFolder(input: $input) {
    note {
      id
    }
  }
}
    `;
export const SearchFolderDocument = gql`
    query SearchFolder($query: String!, $first: Int!) {
  searchFolder(query: $query, first: $first) {
    edges {
      node {
        name
        fixedPath
        group {
          name
          isPrivate
        }
      }
    }
  }
}
    `;
export const SearchNoteDocument = gql`
    query SearchNote($query: String!, $resources: [SearchResourceKind!], $coediting: Boolean, $updated: SearchDate, $groupIds: [ID!], $folderIds: [ID!], $likerIds: [ID!], $isArchived: Boolean, $sortBy: SearchSortKind, $first: Int!) {
  search(
    query: $query
    resources: $resources
    coediting: $coediting
    updated: $updated
    groupIds: $groupIds
    folderIds: $folderIds
    likerIds: $likerIds
    isArchived: $isArchived
    sortBy: $sortBy
    first: $first
  ) {
    edges {
      node {
        document {
          ... on Node {
            id
          }
        }
        title
        url
        contentSummaryHtml
        path
        author {
          account
          realName
        }
      }
    }
  }
}
    `;
export const UpdateNoteContentDocument = gql`
    mutation UpdateNoteContent($input: UpdateNoteContentInput!) {
  updateNoteContent(input: $input) {
    note {
      id
    }
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string, variables?: any) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType, _variables) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    AttachNoteToFolder(variables: AttachNoteToFolderMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<AttachNoteToFolderMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AttachNoteToFolderMutation>(AttachNoteToFolderDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'AttachNoteToFolder', 'mutation', variables);
    },
    CreateComment(variables: CreateCommentMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateCommentMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateCommentMutation>(CreateCommentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'CreateComment', 'mutation', variables);
    },
    CreateCommentReply(variables: CreateCommentReplyMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateCommentReplyMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateCommentReplyMutation>(CreateCommentReplyDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'CreateCommentReply', 'mutation', variables);
    },
    CreateFolder(variables: CreateFolderMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateFolderMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateFolderMutation>(CreateFolderDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'CreateFolder', 'mutation', variables);
    },
    CreateNote(variables: CreateNoteMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateNoteMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateNoteMutation>(CreateNoteDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'CreateNote', 'mutation', variables);
    },
    GetCurrentUser(variables?: GetCurrentUserQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCurrentUserQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCurrentUserQuery>(GetCurrentUserDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetCurrentUser', 'query', variables);
    },
    GetFeedSections(variables: GetFeedSectionsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetFeedSectionsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetFeedSectionsQuery>(GetFeedSectionsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetFeedSections', 'query', variables);
    },
    GetFolder(variables: GetFolderQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetFolderQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetFolderQuery>(GetFolderDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetFolder', 'query', variables);
    },
    GetFolderFromPath(variables: GetFolderFromPathQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetFolderFromPathQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetFolderFromPathQuery>(GetFolderFromPathDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetFolderFromPath', 'query', variables);
    },
    GetFolders(variables: GetFoldersQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetFoldersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetFoldersQuery>(GetFoldersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetFolders', 'query', variables);
    },
    GetGroups(variables: GetGroupsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetGroupsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetGroupsQuery>(GetGroupsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetGroups', 'query', variables);
    },
    GetNote(variables: GetNoteQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetNoteQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetNoteQuery>(GetNoteDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetNote', 'query', variables);
    },
    GetNoteFromPath(variables: GetNoteFromPathQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetNoteFromPathQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetNoteFromPathQuery>(GetNoteFromPathDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetNoteFromPath', 'query', variables);
    },
    GetNotes(variables: GetNotesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetNotesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetNotesQuery>(GetNotesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetNotes', 'query', variables);
    },
    MoveNoteToAnotherFolder(variables: MoveNoteToAnotherFolderMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MoveNoteToAnotherFolderMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MoveNoteToAnotherFolderMutation>(MoveNoteToAnotherFolderDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'MoveNoteToAnotherFolder', 'mutation', variables);
    },
    SearchFolder(variables: SearchFolderQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SearchFolderQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<SearchFolderQuery>(SearchFolderDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'SearchFolder', 'query', variables);
    },
    SearchNote(variables: SearchNoteQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SearchNoteQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<SearchNoteQuery>(SearchNoteDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'SearchNote', 'query', variables);
    },
    UpdateNoteContent(variables: UpdateNoteContentMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UpdateNoteContentMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<UpdateNoteContentMutation>(UpdateNoteContentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'UpdateNoteContent', 'mutation', variables);
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;